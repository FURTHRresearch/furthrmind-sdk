{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"overview/","title":"Overview","text":"<ul> <li>Project</li> </ul>"},{"location":"project/","title":"Project","text":""},{"location":"project/#attributes","title":"Attributes","text":"<p>Projects do have the following attributes:</p> <ul> <li><code>id</code>: id of the project</li> <li><code>name</code>: name of the project</li> <li><code>info</code>: Detailed information belonging to the project</li> <li><code>shortid</code>: shortid of the project</li> <li><code>groups</code>: This is a list of all groups related to this project. Each entry is a partially fetched <code>group</code> object,   containing just the name and id. More details on this can be found in the section   on nested objects.</li> <li><code>samples</code>: This is a list of all samples associated with this project. Each entry is a partially fetched <code>sample</code>   object, containing just the name and id. More details on this can be found in the section   on nested objects.</li> <li><code>experiments</code>: This is a list of all experiments linked to this project. Each entry is a partially   fetched <code>experiment</code> object, containing just the name and id. More details on this can be found in the section   on nested objects.</li> <li><code>resarchitems</code>: This is a dictionary with category name as keys and lists and the corresponding researchitem objects   as values.   Each list entry is a partially fetched <code>researchitem</code> object, containing just the name and id.   More details on this can be found in the section on nested objects.</li> <li><code>fields</code>: This is a list of all fields associated with this project. Each item in the list is a completely   fetched <code>field</code> object.</li> <li><code>units</code>: This is a list of all units belonging to this project. Each item in the list is a completely fetched <code>unit</code>   object</li> <li><code>permissions</code>: This is a dictionary containing various keys. The <code>owner</code> key represents the owner of the project.   The <code>users</code> key refers to a list of users granted access to this project, including their respective access levels.   Lastly, the <code>usergroups</code> key relates to a list of usergroups with access privileges to this project, also presenting   their respective access levels.</li> <li><code>_fetched</code>: This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only   the name and ID are present. For more details, refer to the section on nested objects.</li> </ul>"},{"location":"project/#methods","title":"Methods","text":"<ul> <li>get(id=\"\", name=\"\"): This method can be called on the instance of an object</li> </ul>"},{"location":"references/","title":"References","text":""},{"location":"references/#furthrmind.collection.baseclass.BaseClass","title":"<code>BaseClass</code>","text":"Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>class BaseClass:\n    _data = {}\n    _fetched = False\n    _id = None\n    fm = None\n\n    _attr_definition = {}\n\n    def __init__(self, id=None, data=None):\n        if data:\n            self._update_attributes(data)\n\n        if id:\n            self._id = id\n        else:\n            if \"id\" in self._data:\n                self._id = self._data[\"id\"]\n        if not self._id:\n            raise ValueError(\"No id provided\")\n\n        # create instance methods for certain class_methods\n        instance_methods = [\"get\", \"get_all\", \"get_many\", \"post\", \"delete\",\n                            \"_get\", \"_get_all\", \"_get_many\", \"_post\", \"_delete\"]\n        instance_overload(self, instance_methods)\n\n    def __getitem__(self, item):\n        if hasattr(self, item):\n            return getattr(self, item)\n        else:\n            raise ValueError(\"No such attribute\")\n\n    def __str__(self):\n        class_name = type(self).__name__\n        id = self._id\n        name = \"\"\n        if hasattr(self, \"name\"):\n            name = self.name\n        return f\"{class_name} id: {id}, name: {name}\"\n\n\n    def _get_url_instance(self, project_id=None):\n        return \"\"\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        return \"\"\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        return \"\"\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        return \"\"\n\n    @staticmethod\n    def _update_instance_decorator(_fetched=False):\n        def decorator(function):\n            @wraps(function)\n            def wrapper(*args, **kws):\n                results = function(*args, **kws)\n                results[\"_fetched\"] = _fetched\n                self = args[0]\n                self._update_attributes(results)\n                return self\n\n            return wrapper\n        return decorator\n\n    @staticmethod\n    def _create_instances_decorator(_fetched=False):\n        def decorator(function):\n            @wraps(function)\n            def wrapper(*args, **kws):\n                results = function(*args, **kws)\n                if results is None:\n                    return\n                if isclass(args[0]):\n                    cls = args[0]\n                else:\n                    self = args[0]\n                    cls = self.__class__\n\n                if isinstance(results, list):\n                    item_list = []\n                    for r in results:\n                        r[\"_fetched\"] = _fetched\n                        item = cls(data=r)\n                        item_list.append(item)\n                    return item_list\n                else:\n                    results[\"_fetched\"] = _fetched\n                    item = cls(data=results)\n                    return item\n\n            return wrapper\n        return decorator\n\n    def _update_attributes(self, data):\n        from furthrmind.collection import get_collection_class\n        self._data = data\n\n        def _create_instance(classname, _data):\n            cls = get_collection_class(classname)\n            if isinstance(_data, list):\n                item_list = []\n                for item in _data:\n                    item = cls(self.fm, data=item)\n                    item_list.append(item)\n                item = item_list\n            else:\n                item = cls(self.fm, data=_data)\n            return item\n\n        for key in data:\n            if hasattr(self, key):\n                item = data[key]\n                if key in self._attr_definition:\n                    attr_definition = self._attr_definition[key]\n                    if \"class\" in attr_definition:\n                        if \"nested_dict\" in attr_definition:\n                            item = {}\n                            for item_key in data[key]:\n                                item[item_key] = _create_instance(attr_definition[\"class\"],\n                                                                  data[key][item_key])\n                        else:\n                            if data[key]:\n                                item = _create_instance(attr_definition[\"class\"], data[key])\n                            else:\n                                pass\n\n                setattr(self, key, item)\n            else:\n                for attr_definition in self._attr_definition.items():\n                    definition_key = attr_definition[0]\n                    definition_value = attr_definition[1]\n                    if \"data_key\" in definition_value:\n                        if definition_value[\"data_key\"] == key:\n                            item = data[key]\n                            if \"class\" in definition_value:\n                                item = _create_instance(definition_value[\"class\"], data[key])\n                            setattr(self, definition_key, item)\n                            break\n\n    @classmethod\n    def _get(cls, id=None, shortid=None, name=None, category_name=None, category_id=None,\n             parent_group_id=None, project_id=None):\n\n        if isclass(cls):\n            data = cls._get_class_method(id, shortid, name, category_name, category_id,\n                                         parent_group_id, project_id)\n            return data\n        else:\n            self = cls\n            data = self._get_instance_method()\n            return data\n\n    @_update_instance_decorator(_fetched=True)\n    @furthr_wrap(force_list=False)\n    def _get_instance_method(self):\n        url = self._get_url_instance()\n        data = self.fm.session.get(url)\n        return data\n\n    @classmethod\n    @_create_instances_decorator(_fetched=True)\n    @furthr_wrap(force_list=False)\n    def _get_class_method(cls, id=None, shortid=None, name=None, category_name=None, category_id=None,\n                          parent_group_id=None, project_id=None):\n        if id:\n            if len(id) == 10:\n                shortid = id\n                id = None\n\n        if shortid or name or category_name or category_id or parent_group_id:\n            query = []\n            if shortid:\n                query.append((\"shortid\", shortid))\n            if name:\n                query.append((\"name\", name))\n            if category_name:\n                query.append((\"category_name\", category_name))\n            if category_id:\n                query.append((\"category_id\", category_id))\n            if parent_group_id:\n                query.append((\"parent_group_id\", parent_group_id))\n\n            url_query = parse.urlencode(query)\n            url = cls._get_all_url()\n            url = f\"{url}?{url_query}\"\n        else:\n            url = cls._get_url_class(id, project_id=project_id)\n\n        result = cls.fm.session.get(url)\n\n        return result\n\n    @classmethod\n    def _get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n                  category_name=None, category_id=None,\n                  project_id=None) -&gt; List[Self]:\n        query = []\n        if ids:\n            for id in ids:\n                query.append((\"id\", id))\n        if shortids:\n            for shortid in shortids:\n                query.append((\"shortid\", shortid))\n        if names:\n            for name in names:\n                query.append((\"name\", name))\n        if category_name:\n            query.append((\"category_name\", category_name))\n        if category_id:\n            query.append((\"category_id\", category_id))\n\n        url_query = parse.urlencode(query)\n        if isclass(cls):\n            return cls._get_all_class_method(project_id, url_query)\n        else:\n            self = cls\n            return self._get_all_instance_method(project_id, url_query)\n\n    @classmethod\n    def _get_all(cls, project_id=None) -&gt; List[Self]:\n        if isclass(cls):\n            return cls._get_all_class_method(project_id)\n        else:\n            self = cls\n            return self._get_all_instance_method(project_id)\n\n    @_create_instances_decorator(_fetched=True)\n    @furthr_wrap(force_list=True)\n    def _get_all_instance_method(self, project_id, url_query=\"\"):\n        from .project import Project\n        if isinstance(self, Project):\n            url = self.__class__._get_all_url()\n        else:\n            url = self.__class__._get_all_url(project_id)\n\n        if url_query:\n            url = f\"{url}?{url_query}\"\n        return self.fm.session.get(url)\n\n    @classmethod\n    @_create_instances_decorator(_fetched=True)\n    @furthr_wrap(force_list=True)\n    def _get_all_class_method(cls, project_id, url_query=\"\"):\n        from .project import Project\n        if cls in [Project]:\n            url = cls._get_all_url()\n        else:\n            url = cls._get_all_url(project_id)\n\n        if url_query:\n            url = f\"{url}?{url_query}\"\n        return BaseClass.fm.session.get(url)\n\n\n    @classmethod\n    def _post(cls, data, project_id=None, force_list=False):\n        if isclass(cls):\n            if force_list:\n                return cls._post_class_force_list_method(data, project_id)\n            else:\n                return cls._post_class_method(data, project_id)\n        else:\n            self = cls\n            return self._post_instance_method(data, project_id)\n\n\n    @furthr_wrap(force_list=False)\n    def _post_instance_method(self, data,  project_id=None):\n        url = self.__class__._post_url(project_id)\n        return self.fm.session.post(url, json=data)\n\n    @classmethod\n    @furthr_wrap(force_list=False)\n    def _post_class_method(cls, data, project_id=None):\n        url = cls._post_url(project_id)\n        return cls.fm.session.post(url, json=data)\n\n    @classmethod\n    @furthr_wrap(force_list=True)\n    def _post_class_force_list_method(cls, data, project_id=None):\n        url = cls._post_url(project_id)\n        return cls.fm.session.post(url, json=data)\n\n    @classmethod\n    def delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n        \"\"\"\n        Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n        of a class\n\n        Parameters\n        ----------\n        id : str\n            The id of the resource to delete\n        project_id : str, optional\n            Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        str\n            The id of the item\n        \"\"\"\n\n        if isclass(cls):\n            return cls._delete_class_method(id, project_id)\n        else:\n            self = cls\n            return self._delete_instance_method(project_id)\n\n    @classmethod\n    @furthr_wrap(force_list=False)\n    def _delete_class_method(cls, id, project_id=None):\n        url = cls._get_url_class(id, project_id)\n        return cls.fm.session.delete(url)\n\n    @furthr_wrap(force_list=False)\n    def _delete_instance_method(self, project_id=None):\n        url = self._get_url_instance(project_id)\n        return self.fm.session.delete(url)\n\n    def to_dict(self):\n        \"\"\"\n        Converts the object's attributes to a dictionary representation.\n\n        Returns\n        -------\n        dict\n            Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n        \"\"\"\n\n        from furthrmind import Furthrmind\n        data = {}\n        for attr in dir(self):\n            if attr.startswith('_'):\n                continue\n            value = getattr(self, attr)\n            if callable(value):\n                continue\n            if isinstance(value, Furthrmind):\n                continue\n            data[attr] = self._convert(value)\n        return data\n\n    def _convert(self, item):\n        if isinstance(item, dict):\n            new_item = {}\n            for key, value in item.items():\n                if isinstance(value, (dict, list)):\n                    value = self._convert(value)\n                    new_item[key] = value\n                elif isinstance(value, BaseClass):\n                    value = value.to_dict()\n                    new_item[key] = value\n                else:\n                    new_item[key] = value\n        elif isinstance(item, list):\n            new_item = []\n            for value in item:\n                if isinstance(value, (dict, list)):\n                    value = self._convert(value)\n                    new_item.append(value)\n                elif isinstance(value, BaseClass):\n                    value = value.to_dict()\n                    new_item.append(value)\n                else:\n                    new_item.append(value)\n        elif isinstance(item, BaseClass):\n            new_item = item.to_dict()\n\n        else:\n            new_item = item\n\n        return new_item\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClass.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClass.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData","title":"<code>BaseClassWithFieldData</code>","text":"<p>               Bases: <code>BaseClass</code></p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>class BaseClassWithFieldData(BaseClass):\n    id = None\n    fielddata: List[\"FieldData\"] = []\n\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n        \"\"\"\n        Parameters\n        ----------\n        value : various data types\n            The value to be updated in the field.\n\n            - Numeric fields: float or int, or a string convertible to a float\n            - Date fields: datetime, date object, unix timestamp, or string with iso format\n            - Text fields: string\n            - List fields: dictionary with id or name as key, or string with name, or string with id\n            - Notebook fields: dictionary with content as key, or string\n            - Checkbox fields: boolean\n        field_name : str, optional\n            Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n        field_id : str, optional\n            ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n        Returns\n        -------\n        int\n            The ID of the field that was updated.\n\n        Raises\n        ------\n        ValueError\n            If no field is found with the given `field_id` or `field_name`.\n        \"\"\"\n\n        if not self._fetched:\n            self._get()\n\n        fielddata = None\n        for item in self.fielddata:\n            if fielddata:\n                break\n            if field_id:\n                if item.field_id == field_id:\n                    fielddata = item\n            elif field_name:\n                if item.field_name.lower() == field_name.lower():\n                    fielddata = item\n\n        if not fielddata:\n            raise ValueError(\"No field found with the given field_id or field_name\")\n\n        return fielddata.update_value(value)\n\n    def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n        \"\"\"\n        Method to update the unit of a field.\n\n        Parameters\n        ----------\n        unit : Union[Dict, str]\n            Dictionary with id or name, or string representing the name, or string representing the id.\n        field_name : str, optional\n            The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n        field_id : str, optional\n            The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n        Returns\n        -------\n        id\n            The ID of the updated field.\n\n        Raises\n        ------\n        ValueError\n            If no field is found with the given `field_id` or `field_name`.\n\n        \"\"\"\n\n        if not self._fetched:\n            self._get()\n\n        fielddata = None\n        for item in self.fielddata:\n            if fielddata is not None:\n                break\n            if field_id:\n                if item.field_id == field_id:\n                    fielddata = item\n            elif field_name:\n                if item.field_name.lower() == field_name.lower():\n                    fielddata = item\n\n        if not fielddata:\n            raise ValueError(\"No field found with the given field_id or field_name\")\n\n        return fielddata.update_unit(unit)\n\n    def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n        \"\"\"\n        Method to update a calculation result\n\n        Parameters\n        ----------\n        value : dict\n            Dictionary containing the calculation result to be set for the field.\n        field_name : str, optional\n            Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n        field_id : str, optional\n            ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n        fielddata_id : str, optional\n            ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n        Returns\n        -------\n        id\n            The ID of the fielddata that was updated.\n\n        Raises\n        ------\n        ValueError\n            If no field is found with the given `field_id` or `field_name`.\n        \"\"\"\n\n        if not self._fetched:\n            self._get()\n\n        fielddata = None\n        for item in self.fielddata:\n            if fielddata:\n                break\n            if fielddata_id:\n                if item.id == fielddata_id:\n                    fielddata = item\n            if field_id:\n                if item.fieldid == field_id:\n                    fielddata = item\n            elif field_name:\n                if item.field_name.lower() == field_name.lower():\n                    fielddata = item\n\n        if not fielddata:\n            raise ValueError(\"No field found with the given field_id or field_name\")\n\n        return fielddata.set_calculation_result(value)\n\n    def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n                  value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n        \"\"\"\n        Method to add a field to the current item\n\n        Parameters\n        ----------\n        field_name : str\n            Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n            Either fieldname and fieldtype or field_id must be specified.\n        field_type : str\n            Type of field. Must be one of:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n        field_id : str\n            Id of field that should be added.\n        value : Any\n            Value of the field. The data type of the value depends on the field_type:\n\n            - Numeric fields: float or int, or a string convertible to a float\n            - Date fields: datetime, date object, unix timestamp, or string with iso format\n            - Text fields: string\n            - List fields: dictionary with id or name as key, or string with name, or string with id\n            - Notebook fields: dictionary with content as key, or string\n            - Checkbox fields: boolean\n\n        unit : Union[Dict, str]\n            Dictionary with id or name, or string representing the name, or string representing the id.\n\n        Returns\n        -------\n        FieldData\n            The new FieldData object that was created.\n\n        \"\"\"\n\n        from .fielddata import FieldData\n        if not self._fetched:\n            self._get()\n\n        fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n        new_field_data_list = list(self.fielddata)\n        new_field_data_list.append(fielddata)\n        self.fielddata = new_field_data_list\n\n        data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n        self._post(data)\n        return fielddata\n\n    def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n        \"\"\"\n        Method to add many fields to the current item\n\n        Parameters\n        ----------\n        data_list: List[Dict]\n            List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n            - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n            - field_type:\n                Type of the field. Must be one of the following:\n\n                - Numeric fields: numeric, numeric-field, numeric_field\n                - Date fields: date, date_field, date-field, datefield\n                - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n                - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n                - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n                - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n                - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n            - field_id: ID of the field to be added.\n            - value: Value of the field. The required format depends on the field_type:\n\n                - Numeric: float or int, or a string convertible to a float.\n                - Date: datetime, date object, Unix timestamp, or string in ISO format.\n                - SingleLine: string.\n                - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n                - MultiLine: Dictionary with content as key, or string.\n                - CheckBox: Boolean.\n\n            - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n        Returns\n        -------\n        List[\"FieldData\"]\n            List of FieldData objects representing the added fields.\n\n        \"\"\"\n\n\n        from .fielddata import FieldData\n        if not self._fetched:\n            self._get()\n\n        fielddata_list = FieldData.create_many(data_list)\n\n        new_field_data_list = list(self.fielddata)\n        new_field_data_list.extend(fielddata_list)\n        self.fielddata = new_field_data_list\n\n        data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n        self._post(data)\n        return fielddata_list\n\n\n    def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n        \"\"\"\n        Removes a field from the current item.\n\n        Parameters\n        ----------\n        field_name : str, optional\n            Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n        field_id : str, optional\n            ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n        Returns\n        -------\n        str\n            ID of the item after the field is removed.\n\n        Raises\n        ------\n        ValueError\n            If no field is found with the given `field_name` or `field_id`.\n        \"\"\"\n\n\n        if not self._fetched:\n            self._get()\n\n        new_fielddata_list = []\n        fielddata_to_be_removed = None\n        for fielddata in self.fielddata:\n            found = False\n            if field_id:\n                found = True\n                if fielddata.field_id == field_id:\n                    fielddata_to_be_removed = fielddata\n            elif field_name:\n                found = True\n                if fielddata.field_name == field_name:\n                    fielddata_to_be_removed = fielddata\n            if not found:\n                new_fielddata_list.append(fielddata)\n\n\n        if not fielddata_to_be_removed:\n            raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n        self.fielddata = new_fielddata_list\n        fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n        post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n        id = self._post(post_data)\n        return id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFieldData.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFiles","title":"<code>BaseClassWithFiles</code>","text":"<p>               Bases: <code>BaseClass</code></p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>class BaseClassWithFiles(BaseClass):\n    id = None\n    files = []\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def add_file(self, file_path: str = \"\", file_name: str = \"\", file_id: str = \"\") -&gt; \"File\":\n        \"\"\"\n        Parameters\n        ----------\n        file_path : str, optional\n            File path of the file that should be uploaded.\n        file_name : str, optional\n            Optionally specify the file name if not the original file name should be used.\n        file_id : str, optional\n            ID of the file.\n\n        Returns\n        -------\n        File\n            The file object that has been added.\n\n        Raises\n        ------\n        AssertationError\n            If neither file path nor file_id is specified.\n        ValueError\n            If the file path specified does not exist.\n        \"\"\"\n\n\n        from furthrmind.file_loader import FileLoader\n        from .file import File\n\n        assert file_path or file_id, \"File_path or file_id must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        if not file_id:\n            assert file_path, \"File path must be specified\"\n            if not os.path.isfile(file_path):\n                raise ValueError(\"File does not exist\")\n\n            fl = FileLoader(self.fm.host, self.fm.api_key)\n            file_id, file_name = fl.uploadFile(file_path, file_name)\n            file_data = {\"id\": file_id,\n                         \"name\": file_name}\n        else:\n            file_data = {\"id\": file_id}\n\n        file_list = [{\"id\": f.id} for f in self.files]\n        file_list.append(file_data)\n        post_data = {\"id\": self.id, \"files\": file_list}\n\n        id = self._post(post_data)\n        file = File(data=file_data)\n        new_file_list = list(self.files)\n        new_file_list.append(file)\n        self.files = new_file_list\n        return file\n\n    def remove_file(self, file_id: str = \"\", file_name: str = \"\"):\n        \"\"\"\n        Method to remove a file from the current item\n\n        Parameters\n        ----------\n        file_id: str, optional\n            ID of the file that should be removed. Either `file_id` or `file_name` must be specified.\n        file_name: str, optional\n            Name of the file to be removed.\n\n        Returns\n        -------\n        file_object: dict\n            Object representing the removed file.\n\n        Raises\n        ------\n        ValueError\n            If no file is found with the given `file_id` or `file_name`.\n\n        \"\"\"\n\n        if not self._fetched:\n            self._get()\n\n        new_file_list = []\n        file_to_be_removed = None\n        for file in self.files:\n            found = False\n            if file_id:\n                found = True\n                if file.id == file_id:\n                    file_to_be_removed = file\n            elif file_name:\n                found = True\n                if file.name == file_name:\n                    file_to_be_removed = file\n            if not found:\n                new_file_list.append(file)\n\n        if not file_to_be_removed:\n            raise ValueError(\"No file found with the given file_id or file_name\")\n\n        self.files = new_file_list\n        file_list = [{\"id\": f.id} for f in new_file_list]\n        post_data = {\"id\": self.id, \"files\": file_list}\n        id = self._post(post_data)\n        return id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFiles.add_file","title":"<code>add_file(file_path='', file_name='', file_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path of the file that should be uploaded.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Optionally specify the file name if not the original file name should be used.</p> <code>''</code> <code>file_id</code> <code>str</code> <p>ID of the file.</p> <code>''</code> <p>Returns:</p> Type Description <code>File</code> <p>The file object that has been added.</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If neither file path nor file_id is specified.</p> <code>ValueError</code> <p>If the file path specified does not exist.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_file(self, file_path: str = \"\", file_name: str = \"\", file_id: str = \"\") -&gt; \"File\":\n    \"\"\"\n    Parameters\n    ----------\n    file_path : str, optional\n        File path of the file that should be uploaded.\n    file_name : str, optional\n        Optionally specify the file name if not the original file name should be used.\n    file_id : str, optional\n        ID of the file.\n\n    Returns\n    -------\n    File\n        The file object that has been added.\n\n    Raises\n    ------\n    AssertationError\n        If neither file path nor file_id is specified.\n    ValueError\n        If the file path specified does not exist.\n    \"\"\"\n\n\n    from furthrmind.file_loader import FileLoader\n    from .file import File\n\n    assert file_path or file_id, \"File_path or file_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if not file_id:\n        assert file_path, \"File path must be specified\"\n        if not os.path.isfile(file_path):\n            raise ValueError(\"File does not exist\")\n\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n        file_id, file_name = fl.uploadFile(file_path, file_name)\n        file_data = {\"id\": file_id,\n                     \"name\": file_name}\n    else:\n        file_data = {\"id\": file_id}\n\n    file_list = [{\"id\": f.id} for f in self.files]\n    file_list.append(file_data)\n    post_data = {\"id\": self.id, \"files\": file_list}\n\n    id = self._post(post_data)\n    file = File(data=file_data)\n    new_file_list = list(self.files)\n    new_file_list.append(file)\n    self.files = new_file_list\n    return file\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithFiles.remove_file","title":"<code>remove_file(file_id='', file_name='')</code>","text":"<p>Method to remove a file from the current item</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>str</code> <p>ID of the file that should be removed. Either <code>file_id</code> or <code>file_name</code> must be specified.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be removed.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>file_object</code> <code>dict</code> <p>Object representing the removed file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no file is found with the given <code>file_id</code> or <code>file_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_file(self, file_id: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Method to remove a file from the current item\n\n    Parameters\n    ----------\n    file_id: str, optional\n        ID of the file that should be removed. Either `file_id` or `file_name` must be specified.\n    file_name: str, optional\n        Name of the file to be removed.\n\n    Returns\n    -------\n    file_object: dict\n        Object representing the removed file.\n\n    Raises\n    ------\n    ValueError\n        If no file is found with the given `file_id` or `file_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    new_file_list = []\n    file_to_be_removed = None\n    for file in self.files:\n        found = False\n        if file_id:\n            found = True\n            if file.id == file_id:\n                file_to_be_removed = file\n        elif file_name:\n            found = True\n            if file.name == file_name:\n                file_to_be_removed = file\n        if not found:\n            new_file_list.append(file)\n\n    if not file_to_be_removed:\n        raise ValueError(\"No file found with the given file_id or file_name\")\n\n    self.files = new_file_list\n    file_list = [{\"id\": f.id} for f in new_file_list]\n    post_data = {\"id\": self.id, \"files\": file_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithGroup","title":"<code>BaseClassWithGroup</code>","text":"<p>               Bases: <code>BaseClass</code></p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>class BaseClassWithGroup(BaseClass):\n    id = None\n    groups = []\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    @classmethod\n    def _create(cls, name, group_name: str = \"\", group_id: str = \"\", project_id: str = \"\"):\n        \"\"\"\n        Internal method to create items that belong to a group: exp, sample, researchitem\n\n        Parameters\n        ----------\n        name : str\n            The name of the item to be created.\n\n        group_name : str, optional\n            The name of the group where the new item will belong to. Note that group name can only be considered for groups that\n            are not subgroups. Either `group_name` or `group_id` must be specified.\n\n        group_id : str, optional\n            The id of the group where the new item will belong to. Either `group_name` or `group_id` must be specified.\n\n        project_id : str, optional\n            Optionally, create an item in another project as the `furthrmind sdk` was initiated with.\n\n        Returns\n        -------\n        dict\n            Dictionary representing the data including the generated id of the new item\n        \"\"\"\n\n        data = cls._prepare_data_for_create(name, group_name, group_id, project_id)\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    def _create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Dict]:\n        \"\"\"\n        Parameters\n        ----------\n        data_list : List[Dict]\n            A list of dictionaries representing the data for creating multiple items (samples or experiments).\n            Each dictionary should contain the following keys:\n\n                - name : str\n                    The name of the item to be created.\n                - group_name : str\n                    The name of the group where the new item will belong to.\n                    The group name can be only considered for groups that are not subgroups.\n                    Either group_name or group_id must be specified.\n                - group_id : str\n                    The ID of the group where the new item will belong to.\n                    Either group_name or group_id must be specified.\n\n        project_id : str, optional\n            Optionally, create an item in another project as the `furthrmind sdk` was initiated with.\n\n        Returns\n        -------\n        list\n            A list with Dictionaries representing the data including the generated id of the new item\n\n\n\n        \"\"\"\n\n        new_list = []\n        for data in data_list:\n            new_list.append(cls._prepare_data_for_create(name=data.get(\"name\"), group_name=data.get(\"group_name\"),\n                                                         group_id=data.get(\"group_id\"), project_id=project_id))\n\n        id_list = cls._post(new_list, project_id, force_list=True)\n        for data, id in zip(new_list, id_list):\n            data[\"id\"] = id\n        return new_list\n\n    @classmethod\n    def _prepare_data_for_create(cls, name, group_name = None, group_id=None, project_id=None):\n        from furthrmind.collection import Group\n        assert name, \"Name must be specified\"\n        assert group_name or group_id, \"Either group_name or group_id must be specified\"\n\n        if group_name:\n            group = Group.get(name=group_name, project_id=project_id)\n            if group:\n                group_id = group.id\n\n            if not group_id:\n                raise ValueError(\"No group with Name was found\")\n\n        data = {\"name\": name, \"groups\": [{\"id\": group_id}]}\n\n        return data\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking","title":"<code>BaseClassWithLinking</code>","text":"<p>               Bases: <code>BaseClass</code></p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>class BaseClassWithLinking(BaseClass):\n    id: str = \"\"\n    linked_samples: List[\"Sample\"] = []\n    linked_experiments: List[\"Experiment\"] = []\n    linked_researchitems: Dict[str, List[\"ResearchItem\"]] = []\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def add_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n        \"\"\"\n        This method is used to link an experiment to the current item. If the experiment is already linked to the item,\n        no action is taken.\n\n        Parameters\n        ----------\n        experiment_id : str, optional\n            The ID of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n        experiment_name : str, optional\n            The name of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n\n        Returns\n        -------\n        str\n            The ID of the item.\n\n        Raises\n        ------\n        ValueError\n            If no experiment is found with the given name.\n\n        \"\"\"\n\n        from furthrmind.collection import Experiment\n        assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        if experiment_name:\n            exp = Experiment.get(name=experiment_name)\n            if not exp:\n                raise ValueError(\"No exp found with the given name\")\n            experiment_id = exp.id\n        else:\n            exp = Experiment.get(experiment_id)\n\n        experiment_id_list = [item.id for item in self.linked_experiments]\n        if experiment_id in experiment_id_list:\n            return self.id\n\n        experiment_id_list.append(experiment_id)\n\n        linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n        data = {\n            \"id\": self.id,\n                \"experiments\": linked_experiment\n        }\n\n        self._post(data=data)\n        new_linked_experiments = list(self.linked_experiments)\n        new_linked_experiments.append(exp)\n        self.linked_experiments = new_linked_experiments\n        return self.id\n\n    def remove_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n        \"\"\"\n        Method to remove a linked experiment from the current item.\n\n        Parameters\n        ----------\n        experiment_id : str, optional\n            The ID of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n        experiment_name : str, optional\n            The name of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n\n        Returns\n        -------\n        str\n            The ID of the item after removing the linkage.\n\n        Raises\n        ------\n        ValueError\n            If no experiment is found with the given name.\n        AssertionError\n            If neither `experiment_id` nor `experiment_name` is specified.\n\n        \"\"\"\n\n        from furthrmind.collection import Experiment\n        assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        if experiment_name:\n            exp = Experiment.get(name = experiment_name)\n            if not exp:\n                raise ValueError(\"No exp found with the given name\")\n            experiment_id = exp.id\n\n        experiment_id_list = []\n        new_linked_items = []\n        for item in self.linked_experiments:\n            if item.id == experiment_id:\n                continue\n            new_linked_items.append(item)\n            experiment_id_list.append(item.id)\n\n        linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n        data = {\n            \"id\": self.id,\n                \"experiments\": linked_experiment\n        }\n\n        self._post(data=data)\n        self.linked_experiments = new_linked_items\n        return self.id\n\n    def add_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n        \"\"\"\n        Method is to link a sample to the current item\n\n        Parameters\n        ----------\n        sample_id : str, optional\n            id to the sample you want to link, either id or name must be given\n        sample_name : str, optional\n            name of the sample you want to link, either name or id must be given\n\n        Returns\n        -------\n        str\n            the id of the item\n\n        Raises\n        ------\n        ValueError\n            If no sample found with the given name\n\n        \"\"\"\n\n        from furthrmind.collection import Sample\n        assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        if sample_name:\n            s = Sample.get(name=sample_name)\n            if not s:\n                raise ValueError(\"No sample found with the given name\")\n            sample_id = s.id\n        else:\n            s = Sample.get(sample_id)\n\n        sample_id_list = [item.id for item in self.linked_samples]\n        if sample_id in sample_id_list:\n            return self.id\n\n        sample_id_list.append(sample_id)\n\n        linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n        data = {\n            \"id\": self.id,\n            \"samples\": linked_samples\n        }\n\n        self._post(data=data)\n        new_linked_samples = list(self.linked_samples)\n        new_linked_samples.append(s)\n        self.linked_samples = new_linked_samples\n        return self.id\n\n    def remove_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n        \"\"\"\n        Method is to remove a linked sample from the current item\n\n        Parameters\n        ----------\n        sample_id : str, optional\n            The id of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n        sample_name : str, optional\n            The name of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n\n        Returns\n        -------\n        str\n            The id of the item.\n\n        Raises\n        ------\n        ValueError\n            If no sample is found with the given name.\n\n        Notes\n        -----\n        This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.\n\n        \"\"\"\n\n        from furthrmind.collection import Sample\n        assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        if sample_name:\n            s = Sample.get(name=sample_name)\n            if not s:\n                raise ValueError(\"No sample found with the given name\")\n            sample_id = s.id\n\n        sample_id_list = []\n        new_linked_items = []\n        for item in self.linked_samples:\n            if item.id == sample_id:\n                continue\n            new_linked_items.append(item)\n            sample_id_list.append(item.id)\n\n        linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n        data = {\n            \"id\": self.id,\n            \"samples\": linked_samples\n        }\n        self._post(data=data)\n        self.linked_samples = new_linked_items\n        return self.id\n\n    def add_linked_researchitem(self, researchitem_id: str):\n        \"\"\"\n        Method is to link a research item to the current item\n\n        Parameters\n        ----------\n        researchitem_id : str\n            The id of the research item to be linked. If not specified, the method will raise an assertion error.\n\n        Returns\n        -------\n        str\n            The id of the current research item.\n\n        Raises\n        ------\n        AssertionError\n            If researchitem_id is not specified.\n\n        \"\"\"\n\n        from furthrmind.collection import ResearchItem\n        assert researchitem_id, \"researchitem_id must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        researchitem_id_list = []\n        for cat in self.linked_researchitems:\n            researchitem_id_list.extend([ri_id.id for ri_id in self.linked_researchitems[cat]])\n\n        if researchitem_id in researchitem_id_list:\n            return self.id\n\n        researchitem_id_list.append(researchitem_id)\n\n        linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n\n        data = {\n            \"id\": self.id,\n            \"researchitems\": linked_researchitems\n        }\n\n        self._post(data=data)\n        ri = ResearchItem.get(id=researchitem_id)\n        research_item_dict = dict(self.linked_researchitems)\n        if ri.category.name in self.linked_researchitems:\n            new_linked_researchitems = list(self.linked_researchitems[ri.category.name])\n        else:\n            new_linked_researchitems = []\n\n        new_linked_researchitems.append(ri)\n        research_item_dict[ri.category.name] = new_linked_researchitems\n        self.linked_researchitems = research_item_dict\n\n        return self.id\n\n    def remove_linked_researchitem(self, researchitem_id: str):\n        \"\"\"\n        Method to remove a linked researchitem from the current item\n\n        Parameters\n        ----------\n        researchitem_id : str\n            The ID of the research item you want to unlink\n\n        Returns\n        -------\n        str\n            The ID of the item after removing the linkage.\n        \"\"\"\n\n        assert researchitem_id, \"Either experiment_id must be specified\"\n\n        if not self._fetched:\n            self._get()\n\n        researchitem_id_list = []\n        new_linked_items = {}\n        for cat in self.linked_researchitems:\n            for item in self.linked_researchitems[cat]:\n                if item.id == researchitem_id:\n                    continue\n                if cat not in new_linked_items:\n                    new_linked_items[cat] = []\n                new_linked_items[cat].append(item)\n                researchitem_id_list.append(item.id)\n\n        if researchitem_id in researchitem_id_list:\n            researchitem_id_list.remove(researchitem_id)\n\n        linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n        data = {\n            \"id\": self.id,\n            \"researchitems\": linked_researchitems\n        }\n\n        self._post(data=data)\n        self.linked_researchitems = new_linked_items\n        return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.add_linked_experiment","title":"<code>add_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>This method is used to link an experiment to the current item. If the experiment is already linked to the item, no action is taken.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    This method is used to link an experiment to the current item. If the experiment is already linked to the item,\n    no action is taken.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n    experiment_name : str, optional\n        The name of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n\n    Returns\n    -------\n    str\n        The ID of the item.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name=experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n    else:\n        exp = Experiment.get(experiment_id)\n\n    experiment_id_list = [item.id for item in self.linked_experiments]\n    if experiment_id in experiment_id_list:\n        return self.id\n\n    experiment_id_list.append(experiment_id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    new_linked_experiments = list(self.linked_experiments)\n    new_linked_experiments.append(exp)\n    self.linked_experiments = new_linked_experiments\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.add_linked_researchitem","title":"<code>add_linked_researchitem(researchitem_id)</code>","text":"<p>Method is to link a research item to the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The id of the research item to be linked. If not specified, the method will raise an assertion error.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The id of the current research item.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If researchitem_id is not specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method is to link a research item to the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The id of the research item to be linked. If not specified, the method will raise an assertion error.\n\n    Returns\n    -------\n    str\n        The id of the current research item.\n\n    Raises\n    ------\n    AssertionError\n        If researchitem_id is not specified.\n\n    \"\"\"\n\n    from furthrmind.collection import ResearchItem\n    assert researchitem_id, \"researchitem_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    for cat in self.linked_researchitems:\n        researchitem_id_list.extend([ri_id.id for ri_id in self.linked_researchitems[cat]])\n\n    if researchitem_id in researchitem_id_list:\n        return self.id\n\n    researchitem_id_list.append(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    ri = ResearchItem.get(id=researchitem_id)\n    research_item_dict = dict(self.linked_researchitems)\n    if ri.category.name in self.linked_researchitems:\n        new_linked_researchitems = list(self.linked_researchitems[ri.category.name])\n    else:\n        new_linked_researchitems = []\n\n    new_linked_researchitems.append(ri)\n    research_item_dict[ri.category.name] = new_linked_researchitems\n    self.linked_researchitems = research_item_dict\n\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.add_linked_sample","title":"<code>add_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to link a sample to the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>id to the sample you want to link, either id or name must be given</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>name of the sample you want to link, either name or id must be given</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the id of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample found with the given name</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to link a sample to the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        id to the sample you want to link, either id or name must be given\n    sample_name : str, optional\n        name of the sample you want to link, either name or id must be given\n\n    Returns\n    -------\n    str\n        the id of the item\n\n    Raises\n    ------\n    ValueError\n        If no sample found with the given name\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n    else:\n        s = Sample.get(sample_id)\n\n    sample_id_list = [item.id for item in self.linked_samples]\n    if sample_id in sample_id_list:\n        return self.id\n\n    sample_id_list.append(sample_id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n\n    self._post(data=data)\n    new_linked_samples = list(self.linked_samples)\n    new_linked_samples.append(s)\n    self.linked_samples = new_linked_samples\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.remove_linked_experiment","title":"<code>remove_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>Method to remove a linked experiment from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> <code>AssertionError</code> <p>If neither <code>experiment_id</code> nor <code>experiment_name</code> is specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    Method to remove a linked experiment from the current item.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n    experiment_name : str, optional\n        The name of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n    AssertionError\n        If neither `experiment_id` nor `experiment_name` is specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name = experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n\n    experiment_id_list = []\n    new_linked_items = []\n    for item in self.linked_experiments:\n        if item.id == experiment_id:\n            continue\n        new_linked_items.append(item)\n        experiment_id_list.append(item.id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    self.linked_experiments = new_linked_items\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.remove_linked_researchitem","title":"<code>remove_linked_researchitem(researchitem_id)</code>","text":"<p>Method to remove a linked researchitem from the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The ID of the research item you want to unlink</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method to remove a linked researchitem from the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The ID of the research item you want to unlink\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n    \"\"\"\n\n    assert researchitem_id, \"Either experiment_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    new_linked_items = {}\n    for cat in self.linked_researchitems:\n        for item in self.linked_researchitems[cat]:\n            if item.id == researchitem_id:\n                continue\n            if cat not in new_linked_items:\n                new_linked_items[cat] = []\n            new_linked_items[cat].append(item)\n            researchitem_id_list.append(item.id)\n\n    if researchitem_id in researchitem_id_list:\n        researchitem_id_list.remove(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    self.linked_researchitems = new_linked_items\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.baseclass.BaseClassWithLinking.remove_linked_sample","title":"<code>remove_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to remove a linked sample from the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>The id of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>The name of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample is found with the given name.</p> Notes <p>This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to remove a linked sample from the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        The id of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n    sample_name : str, optional\n        The name of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n\n    Returns\n    -------\n    str\n        The id of the item.\n\n    Raises\n    ------\n    ValueError\n        If no sample is found with the given name.\n\n    Notes\n    -----\n    This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n\n    sample_id_list = []\n    new_linked_items = []\n    for item in self.linked_samples:\n        if item.id == sample_id:\n            continue\n        new_linked_items.append(item)\n        sample_id_list.append(item.id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n    self._post(data=data)\n    self.linked_samples = new_linked_items\n    return self.id\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code>, <code>BaseClassWithFiles</code>, <code>BaseClassWithGroup</code>, <code>BaseClassWithLinking</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the experiment</p> <code>name</code> <code>str</code> <p>name of the experiment</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>class Experiment(BaseClassWithFieldData, BaseClassWithFiles,\n                 BaseClassWithGroup, BaseClassWithLinking):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the experiment\n    name : str\n        name of the experiment\n\n    \"\"\"\n    id = \"\"\n    name = \"\"\n    neglect = False\n    shortid = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n    linked_samples: List[\"Sample\"] = []\n    linked_experiments: List[Self] = []\n    groups: List[\"Group\"] = []\n    linked_researchitems: Dict[str, List[\"ResearchItem\"]] = []\n    datatables: List[\"DataTable\"] = []\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"},\n        \"linked_samples\": {\"class\": \"Sample\"},\n        \"linked_experiments\": {\"class\": \"Experiment\"},\n        \"groups\": {\"class\": \"Group\"},\n        \"linked_researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"datatables\": {\"class\": \"DataTable\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Experiment.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id: str = None) -&gt; str:\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = None, name: str = None, shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get one experiment by its id, name, or short_id\n        If called on an instance of the class, the id of the class is used\n\n        Parameters\n        ----------\n        id : str, optional\n            The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.\n        name : str, optional\n            The name of the experiment to retrieve.\n        shortid : str, optional\n            The short ID of the experiment to retrieve.\n        project_id : str, optional\n            Optionally to get an experiment from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            An instance of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If neither ID nor name nor shortid is specified.\n\n        Example usage:\n            experiment = Experiment.get(id='ex123')\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name or shortid, \"Either id, name, or shortid must be specified\"\n\n        return cls._get(id, shortid, name, project_id=project_id)\n\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all experiment belonging to one project\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of experiment ids.\n        shortids : List[str]\n            List of experiment short ids.\n        names : List[str]\n            List of experiment names.\n        project_id : str, optional\n            Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If none of the ids, shortids, or names are specified.\n\n        \"\"\"\n\n        assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n        return cls._get_many(ids, shortids, names, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all experiment belonging to one project\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the experiment class.\n        \"\"\"\n\n        return cls._get_all(project_id=project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, group_name: str = \"\", group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to create a new experiment\n\n        Parameters\n        ----------\n        name : str\n            The name of the item to be created\n        group_name : str, optional\n            The name of the group where the new item will belong to. Group name can be only considered for groups that\n            are not subgroups. Either group_name or group_id must be specified.\n        group_id : str, optional\n            The id of the group where the new item will belong to. Either group_name or group_id must be specified.\n        project_id : str, optional\n            Optionally, to create an item in another project as the furthrmind sdk was initiated with.\n\n        Returns\n        -------\n        Experiment instance\n            The instance of the experiment class created.\n\n        \"\"\"\n\n        return cls._create(name, group_name, group_id, project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Parameters\n        ----------\n        data_list : List[Dict]\n            List of dictionaries containing information about the experiments to be created.\n            Each dictionary should have the following keys:\n\n            - name: str\n                The name of the experiment.\n            - group_name : str\n                The name of the group where the experiment will belong to.\n                Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.\n            - group_id : str\n                The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.\n\n        project_id : str, optional\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        \"\"\"\n\n        return cls._create_many(data_list, project_id)\n\n    def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\") -&gt; \"DataTable\":\n        \"\"\"\n        Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute\n\n        Parameters\n        ----------\n        name : str\n            Name of the datatable.\n        columns : List[Dict]\n            A list of columns that should be added to the datatable. Each column is represented as a dictionary with the\n            following keys:\n\n            - name : str\n                Name of the column.&lt;/br&gt;\n            - type : str\n                Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n            - data : Union[List[Union[str, float]], pandas.Series]\n                List of column values. Data must fit the specified type of the column.\n                For Text columns, the items must be convertable to strings\n                For Numeric columns, the items must be convertable to floats.\n                Can be a list or a pandas.Series.\n            - unit : dict or str\n                Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n                representing the name or id of the unit.\n        project_id : str, optional\n            Optionally, specify the id of another project to create the datatable in.\n\n        Returns\n        -------\n        DataTable\n            An instance of the DataTable class representing the created datatable.\n\n        \"\"\"\n\n        from furthrmind.collection import DataTable\n        datatable = DataTable.create(name, experiment_id=self.id, columns=columns, project_id=project_id)\n\n        new_datatables = list(self.datatables)\n        new_datatables.append(datatable)\n        self.datatables = new_datatables\n\n        return datatable\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.add_datatable","title":"<code>add_datatable(name, columns, project_id='')</code>","text":"<p>Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the datatable.</p> required <code>columns</code> <code>List[Dict]</code> <p>A list of columns that should be added to the datatable. Each column is represented as a dictionary with the following keys:</p> <ul> <li>name : str     Name of the column.</li> <li>type : str     Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.</li> <li>data : Union[List[Union[str, float]], pandas.Series]     List of column values. Data must fit the specified type of the column.     For Text columns, the items must be convertable to strings     For Numeric columns, the items must be convertable to floats.     Can be a list or a pandas.Series.</li> <li>unit : dict or str     Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string     representing the name or id of the unit.</li> </ul> required <code>project_id</code> <code>str</code> <p>Optionally, specify the id of another project to create the datatable in.</p> <code>''</code> <p>Returns:</p> Type Description <code>DataTable</code> <p>An instance of the DataTable class representing the created datatable.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\") -&gt; \"DataTable\":\n    \"\"\"\n    Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute\n\n    Parameters\n    ----------\n    name : str\n        Name of the datatable.\n    columns : List[Dict]\n        A list of columns that should be added to the datatable. Each column is represented as a dictionary with the\n        following keys:\n\n        - name : str\n            Name of the column.&lt;/br&gt;\n        - type : str\n            Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n        - data : Union[List[Union[str, float]], pandas.Series]\n            List of column values. Data must fit the specified type of the column.\n            For Text columns, the items must be convertable to strings\n            For Numeric columns, the items must be convertable to floats.\n            Can be a list or a pandas.Series.\n        - unit : dict or str\n            Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n            representing the name or id of the unit.\n    project_id : str, optional\n        Optionally, specify the id of another project to create the datatable in.\n\n    Returns\n    -------\n    DataTable\n        An instance of the DataTable class representing the created datatable.\n\n    \"\"\"\n\n    from furthrmind.collection import DataTable\n    datatable = DataTable.create(name, experiment_id=self.id, columns=columns, project_id=project_id)\n\n    new_datatables = list(self.datatables)\n    new_datatables.append(datatable)\n    self.datatables = new_datatables\n\n    return datatable\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.create","title":"<code>create(name, group_name='', group_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create a new experiment</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to be created</p> required <code>group_name</code> <code>str</code> <p>The name of the group where the new item will belong to. Group name can be only considered for groups that are not subgroups. Either group_name or group_id must be specified.</p> <code>''</code> <code>group_id</code> <code>str</code> <p>The id of the group where the new item will belong to. Either group_name or group_id must be specified.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally, to create an item in another project as the furthrmind sdk was initiated with.</p> <code>''</code> <p>Returns:</p> Type Description <code>Experiment instance</code> <p>The instance of the experiment class created.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, group_name: str = \"\", group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to create a new experiment\n\n    Parameters\n    ----------\n    name : str\n        The name of the item to be created\n    group_name : str, optional\n        The name of the group where the new item will belong to. Group name can be only considered for groups that\n        are not subgroups. Either group_name or group_id must be specified.\n    group_id : str, optional\n        The id of the group where the new item will belong to. Either group_name or group_id must be specified.\n    project_id : str, optional\n        Optionally, to create an item in another project as the furthrmind sdk was initiated with.\n\n    Returns\n    -------\n    Experiment instance\n        The instance of the experiment class created.\n\n    \"\"\"\n\n    return cls._create(name, group_name, group_id, project_id)\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing information about the experiments to be created. Each dictionary should have the following keys:</p> <ul> <li>name: str     The name of the experiment.</li> <li>group_name : str     The name of the group where the experiment will belong to.     Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.</li> <li>group_id : str     The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.</li> </ul> required <code>project_id</code> <code>str</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Parameters\n    ----------\n    data_list : List[Dict]\n        List of dictionaries containing information about the experiments to be created.\n        Each dictionary should have the following keys:\n\n        - name: str\n            The name of the experiment.\n        - group_name : str\n            The name of the group where the experiment will belong to.\n            Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.\n        - group_id : str\n            The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.\n\n    project_id : str, optional\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    \"\"\"\n\n    return cls._create_many(data_list, project_id)\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.get","title":"<code>get(id=None, name=None, shortid='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one experiment by its id, name, or short_id If called on an instance of the class, the id of the class is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the experiment to retrieve.</p> <code>None</code> <code>shortid</code> <code>str</code> <p>The short ID of the experiment to retrieve.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get an experiment from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither ID nor name nor shortid is specified.</p> <code>Example usage:</code> <p>experiment = Experiment.get(id='ex123')</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get(cls, id: str = None, name: str = None, shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get one experiment by its id, name, or short_id\n    If called on an instance of the class, the id of the class is used\n\n    Parameters\n    ----------\n    id : str, optional\n        The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.\n    name : str, optional\n        The name of the experiment to retrieve.\n    shortid : str, optional\n        The short ID of the experiment to retrieve.\n    project_id : str, optional\n        Optionally to get an experiment from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        An instance of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If neither ID nor name nor shortid is specified.\n\n    Example usage:\n        experiment = Experiment.get(id='ex123')\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name or shortid, \"Either id, name, or shortid must be specified\"\n\n    return cls._get(id, shortid, name, project_id=project_id)\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all experiment belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get experiments from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list containing instances of the experiment class.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all experiment belonging to one project\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list containing instances of the experiment class.\n    \"\"\"\n\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"references/#furthrmind.collection.experiment.Experiment.get_many","title":"<code>get_many(ids=(), shortids=(), names=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all experiment belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of experiment ids.</p> <code>()</code> <code>shortids</code> <code>List[str]</code> <p>List of experiment short ids.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of experiment names.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get experiments from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If none of the ids, shortids, or names are specified.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all experiment belonging to one project\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of experiment ids.\n    shortids : List[str]\n        List of experiment short ids.\n    names : List[str]\n        List of experiment names.\n    project_id : str, optional\n        Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If none of the ids, shortids, or names are specified.\n\n    \"\"\"\n\n    assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n    return cls._get_many(ids, shortids, names, project_id=project_id)\n</code></pre>"}]}