{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FURTHRmind python package","text":"<p>This package provides a simple and user-friendly way to interact with your FURTHRmind application. It enables users to effortlessly retrieve existing data or write new data into the application.</p>"},{"location":"#install","title":"Install","text":"<p>You can conveniently install <code>furthrmind</code> from PyPi using the following command:</p> <pre><code>pip install furthrmind\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":""},{"location":"#retrieve-objects","title":"Retrieve objects","text":"<p>To initiate an interaction with your server through the Furthrmind class, you need to create an instance of it. You will pass in your server's URL and API key. Don\u2019t forget to provide the name or ID of the project you want to work with.</p> <pre><code>from furthrmind import Furthrmind\nfm = FURTHRmind(host, api_key, project_name=\"my project\")\n</code></pre> <p>Retrieving data necessitates the importation of the relevant collection class. This can be attained either from your Furthrmind instance or by direct import.</p> <pre><code>Experiment = fm.Experiment\nfrom furthrmind.collection import Experiment\n</code></pre> <p>To fetch a specific experiment, invoke the get method of the Experiment class, passing in the desired experiment's ID.</p> <pre><code>exp = fm.Experiment.get(exp_id)\n</code></pre> <p>or</p> <pre><code>exp = Experiment.get(exp_id)\n</code></pre> <p>Both these commands are identical provided the Experiment class was previously imported.</p> <p>You can fetch all the experiments from a project by calling the get_all method which returns a list of instances of the Experiment class.</p> <pre><code>exp_list = Experiment.get_all()\n</code></pre> <p>The Experiment class instance encapsulates all data pertinent to your experiment. For convenience, this class provides several methods including: add_field, add_many_fields, remove_field, update_field_value, update_field_unit, add_file, remove_file, and add_datatable. Details about the available methods for each collection class can be found below.</p>"},{"location":"#nested-objects","title":"Nested objects","text":"<p>In the preceding example, we retrieved one or more experiments from the Furthrmind server. Each experiment encompasses various attributes such as the corresponding samples, research items, and the group to which it belongs. Note that these entities are nested objects.</p> <p>For instance, the 'groups' attribute comprises a list of group instances belonging to the group collection class. To optimize network traffic, these nested objects do not load completely. In other words, all properties, except for the ' id' and 'name', remain unretrieved.</p> <p>To verify whether an object has been fully loaded, you can inspect the <code>_fetched</code> attribute of the object. If an object hasn't been fetched yet, you can invoke the <code>get()</code> method on that object to retrieve it.</p>"},{"location":"#fields-and-fielddata-how-to-locate-specific-field-value-within-an-item","title":"Fields and FieldData: How to locate specific field value within an item","text":"<p>The targeted experiment contains an attribute known as 'fielddata', which is a list comprising FieldData  objects. Unlike Field objects that represent field definitions within a project,  FieldData merges these definitions with a specific value and unit applicable  to a particular item, such as an experiment.</p> <p>If you wish to locate a field value related to a specific item, you can iterate through the 'fielddata' list and  compare the field names. For example, to search for the value of a field named \"width\", you could do the following:</p> <pre><code>for fielddata in exp.fielddata:\n    if fielddata.field_name == \"width\":\n        value = fielddata.value\n</code></pre>"},{"location":"#create-new-objects","title":"Create new objects","text":"<p>To generate a new experiment, you should invoke the <code>create()</code> or <code>create_many()</code> method. It's important to correctly supply the input arguments suitable for each collection class. Specifically, the <code>create</code> method of the <code>Experiment</code> class necessitates passing the new experiment's name, and the name or ID of the group to which it should belong.</p> <p>In case your requirement entails adding an experiment to a subgroup, supplying this subgroup's ID becomes paramount. The <code>create</code> method subsequently gives back an instance of the <code>Experiment</code> class, whereas the <code>create_many</code> method yields a list of <code>Experiment</code> class instances.</p> <pre><code>new_exp = Experiment.create(\"myexperiment2\", group_name=\"My group\"\n</code></pre> <p>Alternatively, to create multiple experiments:</p> <pre><code>experiments = Experiment.create_many([{\"name\": \"exp1\", \"group\": \"group1\"}, {\"name\": \"exp2\", \"group\": \"group2\"}])\n\n</code></pre>"},{"location":"#adding-fields-files-and-datatables","title":"Adding fields, files, and datatables","text":"<p>After you created the new experiment you might want to add some fields, files, and datatables to your experiment. This can be achieved with:</p> <pre><code>new_exp.add_field(field_name=\"My field namy\", field_type=\"Numeric\",\n                  value=5, unit=\"cm\")\nnew_exp.add_many_fields([\n        {\n            \"name\": \"May field name,\n            \"field_type\" =\"Numeric\",\n            \"value: 5, \n            \"unit\": \"cm\"\n        },\n        {\n            \"name\": \"May second field name,\n            \"field_type\" =\"Numeric\",\n            \"value: 10, \n            \"unit\": \"m\"\n        }\n])\nnew_exp.add_file(my_file_path)\nnew_exp.add_datatable(name=my data table, columns=[\n        {\n            \"name\": \"my 1st column\"\n            \"type\": \"Numeric,\n            \"unit\": \"cm\",\n            \"data\": [1,2,3]\n        },\n        {\n            \"name\": \"my 2nd column\"\n            \"type\": \"Numeric,\n            \"unit\": \"cm\",\n            \"data\": [4,5,6]\n        },\n])\n</code></pre>"},{"location":"#detailed-information-about-each-collection-and-its-attributes-and-methods-can-be-found-here","title":"Detailed information about each collection and its attributes and methods can be found here:","text":"<ul> <li>Project</li> <li>Group</li> <li>Experiment</li> <li>Sample</li> <li>ResearchItem</li> <li>File</li> <li>Field</li> <li>FieldData</li> <li>DataTable</li> <li>Column</li> <li>ComboBoxEntry</li> <li>Unit</li> <li>Category</li> </ul>"},{"location":"category/","title":"Category","text":""},{"location":"category/#furthrmind.collection.category.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the category</p> <code>name</code> <code>str</code> <p>name of the category</p> <code>description</code> <code>str</code> <p>Description of the category</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/category.py</code> <pre><code>class Category(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the category\n    name : str\n        name of the category\n    description : str\n        Description of the category\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    description = \"\"\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Category.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchcategory/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchcategory/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchcategory\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchcategory\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get a category by its id.\n\n        Parameters\n        ----------\n        id : str\n            The id of the requested category. Only needed if used on as a class method\n        project_id : str\n            The project_id parameter is optional and can be used to retrieve categories\n            from another project as the furthrmind sdk was initiated with.\n\n        Returns\n        -------\n        Self\n            An instance of the category class.\n\n        Raises\n        ------\n        AssertionError\n            If used as a class method and id is not specified.\n        \"\"\"\n\n        if isclass(cls):\n            assert id, \"id must be specified\"\n        return super()._get(id=id, project_id=project_id)\n\n\n    # noinspection PyMethodOverriding\n    @classmethod\n    def get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get a category by its ids.\n\n        Parameters\n        ----------\n        ids : List[str]\n            List with ids.\n        project_id : str, optional\n            Optionally, to get experiments from another project as the furthrmind sdk was initiated with. Defaults to None.\n\n        Returns\n        -------\n        List[Self]\n            List with instances of the category class.\n\n        Raises\n        ------\n        AssertionError\n            If ids or names are not specified.\n        \"\"\"\n\n        assert ids, \"ids must be specified\"\n        return cls._get_many(ids, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all categories.\n\n        Parameters\n        ----------\n        project_id : str (optional)\n            Optionally to get categories from another project as the furthrmind sdk was initiated with, defaults to None\n\n        Returns\n        -------\n        List[Self]\n            List with instances of category class\n        \"\"\"\n\n        return cls._get_all(project_id=project_id)\n\n    @staticmethod\n    def create(name: str, project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to create a new category\n\n        Parameters\n        ----------\n        name : str\n            Name of the new category\n\n        project_id : str, optional\n            Identifier of another project where the category should be created,\n            defaults to an empty string\n\n        Returns\n        -------\n        Self\n            The newly created category object\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.create","title":"<code>create(name, project_id='')</code>  <code>staticmethod</code>","text":"<p>Method to create a new category</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the new category</p> required <code>project_id</code> <code>str</code> <p>Identifier of another project where the category should be created, defaults to an empty string</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>The newly created category object</p> Source code in <code>furthrmind/collection/category.py</code> <pre><code>@staticmethod\ndef create(name: str, project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to create a new category\n\n    Parameters\n    ----------\n    name : str\n        Name of the new category\n\n    project_id : str, optional\n        Identifier of another project where the category should be created,\n        defaults to an empty string\n\n    Returns\n    -------\n    Self\n        The newly created category object\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.get","title":"<code>get(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get a category by its id.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the requested category. Only needed if used on as a class method</p> <code>''</code> <code>project_id</code> <code>str</code> <p>The project_id parameter is optional and can be used to retrieve categories from another project as the furthrmind sdk was initiated with.</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the category class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If used as a class method and id is not specified.</p> Source code in <code>furthrmind/collection/category.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get a category by its id.\n\n    Parameters\n    ----------\n    id : str\n        The id of the requested category. Only needed if used on as a class method\n    project_id : str\n        The project_id parameter is optional and can be used to retrieve categories\n        from another project as the furthrmind sdk was initiated with.\n\n    Returns\n    -------\n    Self\n        An instance of the category class.\n\n    Raises\n    ------\n    AssertionError\n        If used as a class method and id is not specified.\n    \"\"\"\n\n    if isclass(cls):\n        assert id, \"id must be specified\"\n    return super()._get(id=id, project_id=project_id)\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all categories.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str(optional)</code> <p>Optionally to get categories from another project as the furthrmind sdk was initiated with, defaults to None</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List with instances of category class</p> Source code in <code>furthrmind/collection/category.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all categories.\n\n    Parameters\n    ----------\n    project_id : str (optional)\n        Optionally to get categories from another project as the furthrmind sdk was initiated with, defaults to None\n\n    Returns\n    -------\n    List[Self]\n        List with instances of category class\n    \"\"\"\n\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.get_many","title":"<code>get_many(ids=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get a category by its ids.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List with ids.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally, to get experiments from another project as the furthrmind sdk was initiated with. Defaults to None.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List with instances of the category class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If ids or names are not specified.</p> Source code in <code>furthrmind/collection/category.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get a category by its ids.\n\n    Parameters\n    ----------\n    ids : List[str]\n        List with ids.\n    project_id : str, optional\n        Optionally, to get experiments from another project as the furthrmind sdk was initiated with. Defaults to None.\n\n    Returns\n    -------\n    List[Self]\n        List with instances of the category class.\n\n    Raises\n    ------\n    AssertionError\n        If ids or names are not specified.\n    \"\"\"\n\n    assert ids, \"ids must be specified\"\n    return cls._get_many(ids, project_id=project_id)\n</code></pre>"},{"location":"category/#furthrmind.collection.category.Category.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"column/","title":"Column","text":""},{"location":"column/#furthrmind.collection.column.Column","title":"<code>Column</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the column</p> <code>name</code> <code>str</code> <p>name of the column</p> <code>type</code> <code>str</code> <p>Type of the column. Either \"Text\" or \"Numeric\"</p> <code>values</code> <code>List[Any]</code> <p>\"These represent the values held within the column. If the column type is 'Text', the values are characterized as strings. Conversely, for 'Numeric' type columns, the values are expressed as floating-point numbers.\"</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/column.py</code> <pre><code>class Column(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the column\n    name : str\n        name of the column\n    type : str\n        Type of the column. Either \"Text\" or \"Numeric\"\n    values : List[Any]\n        \"These represent the values held within the column. If the column type is 'Text',\n        the values are characterized as strings. Conversely, for 'Numeric' type columns,\n        the values are expressed as floating-point numbers.\"\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id: str = \"\"\n    name: str = \"\"\n    type: str = \"\"\n    values: List[Any] = []\n\n    _attr_definition = {\"columns\": {\"class\": \"Column\"}}\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    @classmethod\n    def get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n\n        \"\"\"\n        Method to get one column by its id\n        If called on an instance of the class, the id of the instance is used\n\n        Parameters\n        ----------\n        id : str\n            id of requested column\n        project_id : str, optional\n            Optionally to get a column from another project as the furthrmind sdk was initiated with, defaults to \"\"\n\n        Returns\n        -------\n        Self\n            Instance of column class\n\n        Raises\n        ------\n        AssertionError\n            If used as a class method and id is not specified.\n        \"\"\"\n\n        if isclass(cls):\n            assert id, \"id must be specified\"\n\n        return cls._get(id, project_id=project_id)\n\n    # noinspection PyMethodOverriding\n    @classmethod\n    def get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get many columns belonging to one project\n\n        Parameters\n        ----------\n        ids : List[str]\n            List with ids.\n\n        project_id : str\n            Optionally, the id of the project from which to get the experiments. Defaults to an empty string.\n\n        Returns\n        -------\n        List[Self]\n            List with instances of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If `ids` is not specified.\n        \"\"\"\n\n        assert ids, \"ids must be specified\"\n        return cls._get_many(ids, project_id=project_id)\n\n    @classmethod\n    def _get_all(cls, project_id=None) -&gt; List[Self]:\n        raise ValueError(\"Not implemented for columns\")\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Column.fm.get_project_url(project_id)\n        url = f\"{project_url}/column/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/column/{id}\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/column\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/column\"\n        return url\n\n    @classmethod\n    def _type_check(cls, column_type, data):\n        if not column_type in [\"Text\", \"Numeric\"]:\n            raise ValueError(\"Column type must be Text/Numeric\")\n        if isinstance(data, pandas.Series):\n            data = data.tolist()\n\n        new_data = []\n        for d in data:\n            try:\n                if math.isnan(d):\n                    new_data.append(None)\n                else:\n                    new_data.append(d)\n            except:\n                new_data.append(d)  # data = [d if not math.isnan(d) else None for d in data]\n        data = new_data\n        if column_type == \"Text\":\n            if all([isinstance(d, (str, type(None))) for d in data]):\n                return data\n            return [str(d) for d in data]\n\n        elif column_type == \"Numeric\":\n            if all([isinstance(d, (int, float, type(None))) for d in data]):\n                return data\n            new_data = []\n            for d in data:\n                if d is None:\n                    new_data.append(d)\n                try:\n                    new_data.append(float(d))\n                except:\n                    raise ValueError(\n                        \"All column values must be a float, int or a string that can be converted to a float\")\n            return new_data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, type: str, data: list, unit=None, project_id=None) -&gt; Self:\n        \"\"\"\n        Method to create a new column\n\n        Parameters\n        ----------\n        name : str\n            Name of the column\n        type : str\n            The column type is categorized as either \"Text\" or \"Numeric\". For the \"Text\" type, all data\n            will be transformed into strings. Conversely, for the \"Numeric\" type, data will be converted\n            into floats, provided such a conversion is feasible. Please ensure that your data corresponds\n            to the assigned column type.\n        data : Union[list, pandas.Series]\n            This should be either a list or a pandas series. Its values need to comply with the specified column type\n            and will undergo conversion based on the rules described above.\n        unit : Optional[Union[str, Dict]]\n            Dict with id or name, or name as string, or id as string\n        project_id : Optional[str]\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of column class\n\n        \"\"\"\n        data = cls._type_check(type, data)\n        unit = FieldData._check_unit(unit)\n        data_dict = {\"name\": name, \"type\": type, \"values\": data, \"unit\": unit}\n        id = cls._post(data_dict, project_id)\n        data_dict[\"id\"] = id\n        return data_dict\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to create many new columns\n\n        Parameters\n        ----------\n        data_list : List[Dict]\n            A list of dictionaries containing information about the data columns to be created. Each dictionary should\n             have the following keys:\n\n                - name: Name of the column\n                - type: Type of the column. Allowed values are \"Text\" or \"Numeric\".\n                - data: List of column values. The values must match the column type. Can also be a pandas data series.\n                - unit: Optional. Dictionary with id or name, or name as a string, or id as a string.\n\n        project_id : str, optional\n            Optionally to create columns in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instances of the column class.\n\n        \"\"\"\n\n        new_data_list = []\n        for item in data_list:\n            type = item.get(\"type\")\n            unit = item.get(\"unit\")\n            name = item.get(\"name\")\n            data = item.get(\"data\")\n            data = cls._type_check(type, data)\n            unit = FieldData._check_unit(unit)\n            data_dict = {\"name\": name, \"type\": type, \"values\": data, \"unit\": unit}\n            new_data_list.append(data_dict)\n\n        id_list = cls._post(new_data_list, project_id, force_list=True)\n        for item, id in zip(new_data_list, id_list):\n            item[\"id\"] = id\n\n        return new_data_list\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.create","title":"<code>create(name, type, data, unit=None, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to create a new column</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the column</p> required <code>type</code> <code>str</code> <p>The column type is categorized as either \"Text\" or \"Numeric\". For the \"Text\" type, all data will be transformed into strings. Conversely, for the \"Numeric\" type, data will be converted into floats, provided such a conversion is feasible. Please ensure that your data corresponds to the assigned column type.</p> required <code>data</code> <code>Union[list, Series]</code> <p>This should be either a list or a pandas series. Its values need to comply with the specified column type and will undergo conversion based on the rules described above.</p> required <code>unit</code> <code>Optional[Union[str, Dict]]</code> <p>Dict with id or name, or name as string, or id as string</p> <code>None</code> <code>project_id</code> <code>Optional[str]</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of column class</p> Source code in <code>furthrmind/collection/column.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, type: str, data: list, unit=None, project_id=None) -&gt; Self:\n    \"\"\"\n    Method to create a new column\n\n    Parameters\n    ----------\n    name : str\n        Name of the column\n    type : str\n        The column type is categorized as either \"Text\" or \"Numeric\". For the \"Text\" type, all data\n        will be transformed into strings. Conversely, for the \"Numeric\" type, data will be converted\n        into floats, provided such a conversion is feasible. Please ensure that your data corresponds\n        to the assigned column type.\n    data : Union[list, pandas.Series]\n        This should be either a list or a pandas series. Its values need to comply with the specified column type\n        and will undergo conversion based on the rules described above.\n    unit : Optional[Union[str, Dict]]\n        Dict with id or name, or name as string, or id as string\n    project_id : Optional[str]\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of column class\n\n    \"\"\"\n    data = cls._type_check(type, data)\n    unit = FieldData._check_unit(unit)\n    data_dict = {\"name\": name, \"type\": type, \"values\": data, \"unit\": unit}\n    id = cls._post(data_dict, project_id)\n    data_dict[\"id\"] = id\n    return data_dict\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create many new columns</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>A list of dictionaries containing information about the data columns to be created. Each dictionary should  have the following keys:</p> <pre><code>- name: Name of the column\n- type: Type of the column. Allowed values are \"Text\" or \"Numeric\".\n- data: List of column values. The values must match the column type. Can also be a pandas data series.\n- unit: Optional. Dictionary with id or name, or name as a string, or id as a string.\n</code></pre> required <code>project_id</code> <code>str</code> <p>Optionally to create columns in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instances of the column class.</p> Source code in <code>furthrmind/collection/column.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to create many new columns\n\n    Parameters\n    ----------\n    data_list : List[Dict]\n        A list of dictionaries containing information about the data columns to be created. Each dictionary should\n         have the following keys:\n\n            - name: Name of the column\n            - type: Type of the column. Allowed values are \"Text\" or \"Numeric\".\n            - data: List of column values. The values must match the column type. Can also be a pandas data series.\n            - unit: Optional. Dictionary with id or name, or name as a string, or id as a string.\n\n    project_id : str, optional\n        Optionally to create columns in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instances of the column class.\n\n    \"\"\"\n\n    new_data_list = []\n    for item in data_list:\n        type = item.get(\"type\")\n        unit = item.get(\"unit\")\n        name = item.get(\"name\")\n        data = item.get(\"data\")\n        data = cls._type_check(type, data)\n        unit = FieldData._check_unit(unit)\n        data_dict = {\"name\": name, \"type\": type, \"values\": data, \"unit\": unit}\n        new_data_list.append(data_dict)\n\n    id_list = cls._post(new_data_list, project_id, force_list=True)\n    for item, id in zip(new_data_list, id_list):\n        item[\"id\"] = id\n\n    return new_data_list\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.get","title":"<code>get(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one column by its id If called on an instance of the class, the id of the instance is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of requested column</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get a column from another project as the furthrmind sdk was initiated with, defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of column class</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If used as a class method and id is not specified.</p> Source code in <code>furthrmind/collection/column.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n\n    \"\"\"\n    Method to get one column by its id\n    If called on an instance of the class, the id of the instance is used\n\n    Parameters\n    ----------\n    id : str\n        id of requested column\n    project_id : str, optional\n        Optionally to get a column from another project as the furthrmind sdk was initiated with, defaults to \"\"\n\n    Returns\n    -------\n    Self\n        Instance of column class\n\n    Raises\n    ------\n    AssertionError\n        If used as a class method and id is not specified.\n    \"\"\"\n\n    if isclass(cls):\n        assert id, \"id must be specified\"\n\n    return cls._get(id, project_id=project_id)\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.get_many","title":"<code>get_many(ids=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get many columns belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List with ids.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally, the id of the project from which to get the experiments. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List with instances of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>ids</code> is not specified.</p> Source code in <code>furthrmind/collection/column.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get many columns belonging to one project\n\n    Parameters\n    ----------\n    ids : List[str]\n        List with ids.\n\n    project_id : str\n        Optionally, the id of the project from which to get the experiments. Defaults to an empty string.\n\n    Returns\n    -------\n    List[Self]\n        List with instances of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If `ids` is not specified.\n    \"\"\"\n\n    assert ids, \"ids must be specified\"\n    return cls._get_many(ids, project_id=project_id)\n</code></pre>"},{"location":"column/#furthrmind.collection.column.Column.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"comboboxentry/","title":"ComboBoxEntry","text":""},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry","title":"<code>ComboBoxEntry</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code></p> <p>ComboBoxEntries represent the available options in a list field</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the column</p> <code>name</code> <code>str</code> <p>name of the column</p> <code>files</code> <code>List[File]</code> <p>List of files belonging to this comboboxentry. See File for more information.</p> <code>fielddata</code> <code>List[FieldData]</code> <p>List of field data belonging to this comboboxentry. See FieldData for more information.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>class ComboBoxEntry(BaseClassWithFieldData):\n    \"\"\"\n    ComboBoxEntries represent the available options in a list field\n\n    Attributes\n    ----------\n    id : str\n        id of the column\n    name : str\n        name of the column\n    files : List[File]\n        List of files belonging to this comboboxentry. See [File](file.md) for more information.\n    fielddata : List[FieldData]\n        List of field data belonging to this comboboxentry. See [FieldData](fielddata.md) for more information.\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = ComboBoxEntry.fm.get_project_url(project_id)\n        url = f\"{project_url}/comboboxentry/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/comboboxentry/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/comboboxentry\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/comboboxentry\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get one combobox entry\n        If called on an instance of the class, the id of the instance is used\n\n        Parameters\n        ----------\n        id : str\n            id of the requested comboboxentry\n        project_id : str\n            Optionally, to get a comboboxentry from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of the ComboBoxEntry class\n\n        Raises\n        ------\n        AssertionError\n            If used as class method and id not specified\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id, \"id must be specified\"\n\n        return cls._get(id, project_id=project_id)\n\n    # noinspection PyMethodOverriding\n    @classmethod\n    def get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        This method is a class method that retrieves multiple comboboxentries belonging to one project.\n\n        Parameters\n        ----------\n        ids : List[str]\n            List with ids.\n\n        project_id : str, optional\n            Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with,\n            defaults to an empty string.\n\n        Returns\n        -------\n        List[Self]\n            List with instances of experiment class.\n\n        Raises\n        ------\n        AssertError\n            If `ids` list is empty.\n\n        \"\"\"\n\n        assert ids, \"ids must be specified\"\n        return cls._get_many(ids, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all comboboxentries belonging to one project.\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the comboboxentry class.\n        \"\"\"\n\n        return cls._get_all(project_id=project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, field_name: str = \"\", field_id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to create a new combobox entry\n\n        Parameters\n        ----------\n        name: str\n            Name of the combobox entry.\n        field_name: str, optional\n            Name of the field where the combobox entry should belong to. Either the field name or id must be provided.\n        field_id: str, optional\n            Id of the field where the combobox entry should belong to. Either the field name or id must be provided.\n        project_id: str, optional\n            Id of the project where the combobox entry should be created. This is only required if the combobox entry needs to\n            be created in a different project than the one the SDK was initiated with.\n\n        Returns\n        -------\n        Self\n            Instance of the column comboboxentry class.\n\n        Raises\n        ------\n        ValueError\n            If the name is not specified.\n        ValueError\n            If neither field_name nor field_id is provided.\n        ValueError\n            If the field with the given name is not found.\n        \"\"\"\n\n        from furthrmind.collection.field import Field\n\n        if not name:\n            raise ValueError(\"Name must be specified\")\n        if not field_name and not field_id:\n            raise ValueError(\"Either field_name or field_id must be provided\")\n\n        if field_name:\n            fields = Field._get_all(project_id)\n            for field in fields:\n                if field.name.lower() == field_name.lower():\n                    field_id = field.id\n                    break\n\n            if not field_id:\n                raise ValueError(\"Field with given name not found\")\n\n        data = {\"name\": name, \"field\": {\"id\": field_id}}\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to create many new combobox entries\n\n        Parameters\n        ----------\n        data_list : List[Dict]\n            List of dictionaries containing the data for creating instances of comboboxentry class. Each dictionary\n            should have the following keys:\n\n            - \"name\" (str): Name of the combobox entry.\n            - \"field_name\" (str, optional): Name of the field where the combobox entry should belong to. Either\n                \"field_name\" or \"field_id\" must be provided.\n            - \"field_id\" (str, optional): ID of the field where the combobox entry should belong to. Either \"field_name\"\n                or \"field_id\" must be provided.\n\n        project_id : str, optional\n            ID of the project where the combobox entries should be created. If not provided, the items will be created\n            in the current project.\n\n        Returns\n        -------\n        List[Self]\n            List of instances of comboboxentry class that were created.\n\n        Raises\n        ------\n        ValueError\n            If any of the following conditions are met:\n\n            - \"name\" is missing in any of the dictionaries in \"data_list\".\n            - Both \"field_name\" and \"field_id\" are missing in any of the dictionaries in \"data_list\".\n            - The provided \"field_name\" does not match any existing field in the project.\n\n        \"\"\"\n\n        from furthrmind.collection.field import Field\n\n        look_for_field_ids = False\n        for data in data_list:\n            if not data.get(\"name\"):\n                raise ValueError(\"Name must be specified\")\n\n            if data.get(\"field_name\"):\n                look_for_field_ids = True\n                break\n\n        if look_for_field_ids:\n            fields = Field._get_all(project_id)\n            for data in data_list:\n                field_name = data.get(\"field_name\")\n                field_id = data.get(\"field_id\")\n                if not field_name and not field_id:\n                    raise ValueError(\"Either field_name or field_id must be provided\")\n                if field_name:\n                    for field in fields:\n                        if field.name.lower() == field_name.lower():\n                            field_id = field.id\n                            data[\"field_id\"] = field_id\n                            break\n                        if not data.get(\"field_id\"):\n                            raise ValueError(f\"Field with given name '{field_name}' not found\")\n\n        new_data_list = []\n        for data in data_list:\n            new_data_list.append({\n                \"name\": data.get(\"name\"),\n                \"field\": {\"id\": data.get(\"field_id\")}\n            })\n\n        id_list = cls._post(new_data_list, project_id, force_list=True)\n        for data, id in zip(new_data_list, id_list):\n            data[\"id\"] = id\n\n        return new_data_list\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.create","title":"<code>create(name, field_name='', field_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create a new combobox entry</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the combobox entry.</p> required <code>field_name</code> <code>str</code> <p>Name of the field where the combobox entry should belong to. Either the field name or id must be provided.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of the field where the combobox entry should belong to. Either the field name or id must be provided.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Id of the project where the combobox entry should be created. This is only required if the combobox entry needs to be created in a different project than the one the SDK was initiated with.</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the column comboboxentry class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name is not specified.</p> <code>ValueError</code> <p>If neither field_name nor field_id is provided.</p> <code>ValueError</code> <p>If the field with the given name is not found.</p> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, field_name: str = \"\", field_id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to create a new combobox entry\n\n    Parameters\n    ----------\n    name: str\n        Name of the combobox entry.\n    field_name: str, optional\n        Name of the field where the combobox entry should belong to. Either the field name or id must be provided.\n    field_id: str, optional\n        Id of the field where the combobox entry should belong to. Either the field name or id must be provided.\n    project_id: str, optional\n        Id of the project where the combobox entry should be created. This is only required if the combobox entry needs to\n        be created in a different project than the one the SDK was initiated with.\n\n    Returns\n    -------\n    Self\n        Instance of the column comboboxentry class.\n\n    Raises\n    ------\n    ValueError\n        If the name is not specified.\n    ValueError\n        If neither field_name nor field_id is provided.\n    ValueError\n        If the field with the given name is not found.\n    \"\"\"\n\n    from furthrmind.collection.field import Field\n\n    if not name:\n        raise ValueError(\"Name must be specified\")\n    if not field_name and not field_id:\n        raise ValueError(\"Either field_name or field_id must be provided\")\n\n    if field_name:\n        fields = Field._get_all(project_id)\n        for field in fields:\n            if field.name.lower() == field_name.lower():\n                field_id = field.id\n                break\n\n        if not field_id:\n            raise ValueError(\"Field with given name not found\")\n\n    data = {\"name\": name, \"field\": {\"id\": field_id}}\n    id = cls._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create many new combobox entries</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the data for creating instances of comboboxentry class. Each dictionary should have the following keys:</p> <ul> <li>\"name\" (str): Name of the combobox entry.</li> <li>\"field_name\" (str, optional): Name of the field where the combobox entry should belong to. Either     \"field_name\" or \"field_id\" must be provided.</li> <li>\"field_id\" (str, optional): ID of the field where the combobox entry should belong to. Either \"field_name\"     or \"field_id\" must be provided.</li> </ul> required <code>project_id</code> <code>str</code> <p>ID of the project where the combobox entries should be created. If not provided, the items will be created in the current project.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of comboboxentry class that were created.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the following conditions are met:</p> <ul> <li>\"name\" is missing in any of the dictionaries in \"data_list\".</li> <li>Both \"field_name\" and \"field_id\" are missing in any of the dictionaries in \"data_list\".</li> <li>The provided \"field_name\" does not match any existing field in the project.</li> </ul> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to create many new combobox entries\n\n    Parameters\n    ----------\n    data_list : List[Dict]\n        List of dictionaries containing the data for creating instances of comboboxentry class. Each dictionary\n        should have the following keys:\n\n        - \"name\" (str): Name of the combobox entry.\n        - \"field_name\" (str, optional): Name of the field where the combobox entry should belong to. Either\n            \"field_name\" or \"field_id\" must be provided.\n        - \"field_id\" (str, optional): ID of the field where the combobox entry should belong to. Either \"field_name\"\n            or \"field_id\" must be provided.\n\n    project_id : str, optional\n        ID of the project where the combobox entries should be created. If not provided, the items will be created\n        in the current project.\n\n    Returns\n    -------\n    List[Self]\n        List of instances of comboboxentry class that were created.\n\n    Raises\n    ------\n    ValueError\n        If any of the following conditions are met:\n\n        - \"name\" is missing in any of the dictionaries in \"data_list\".\n        - Both \"field_name\" and \"field_id\" are missing in any of the dictionaries in \"data_list\".\n        - The provided \"field_name\" does not match any existing field in the project.\n\n    \"\"\"\n\n    from furthrmind.collection.field import Field\n\n    look_for_field_ids = False\n    for data in data_list:\n        if not data.get(\"name\"):\n            raise ValueError(\"Name must be specified\")\n\n        if data.get(\"field_name\"):\n            look_for_field_ids = True\n            break\n\n    if look_for_field_ids:\n        fields = Field._get_all(project_id)\n        for data in data_list:\n            field_name = data.get(\"field_name\")\n            field_id = data.get(\"field_id\")\n            if not field_name and not field_id:\n                raise ValueError(\"Either field_name or field_id must be provided\")\n            if field_name:\n                for field in fields:\n                    if field.name.lower() == field_name.lower():\n                        field_id = field.id\n                        data[\"field_id\"] = field_id\n                        break\n                    if not data.get(\"field_id\"):\n                        raise ValueError(f\"Field with given name '{field_name}' not found\")\n\n    new_data_list = []\n    for data in data_list:\n        new_data_list.append({\n            \"name\": data.get(\"name\"),\n            \"field\": {\"id\": data.get(\"field_id\")}\n        })\n\n    id_list = cls._post(new_data_list, project_id, force_list=True)\n    for data, id in zip(new_data_list, id_list):\n        data[\"id\"] = id\n\n    return new_data_list\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.get","title":"<code>get(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one combobox entry If called on an instance of the class, the id of the instance is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the requested comboboxentry</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally, to get a comboboxentry from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the ComboBoxEntry class</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If used as class method and id not specified</p> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get one combobox entry\n    If called on an instance of the class, the id of the instance is used\n\n    Parameters\n    ----------\n    id : str\n        id of the requested comboboxentry\n    project_id : str\n        Optionally, to get a comboboxentry from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of the ComboBoxEntry class\n\n    Raises\n    ------\n    AssertionError\n        If used as class method and id not specified\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id, \"id must be specified\"\n\n    return cls._get(id, project_id=project_id)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all comboboxentries belonging to one project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list containing instances of the comboboxentry class.</p> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all comboboxentries belonging to one project.\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list containing instances of the comboboxentry class.\n    \"\"\"\n\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.get_many","title":"<code>get_many(ids=(), project_id='')</code>  <code>classmethod</code>","text":"<p>This method is a class method that retrieves multiple comboboxentries belonging to one project.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List with ids.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with, defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List with instances of experiment class.</p> <p>Raises:</p> Type Description <code>AssertError</code> <p>If <code>ids</code> list is empty.</p> Source code in <code>furthrmind/collection/comboboxentry.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    This method is a class method that retrieves multiple comboboxentries belonging to one project.\n\n    Parameters\n    ----------\n    ids : List[str]\n        List with ids.\n\n    project_id : str, optional\n        Optionally to get comboboxentries from another project as the furthrmind sdk was initiated with,\n        defaults to an empty string.\n\n    Returns\n    -------\n    List[Self]\n        List with instances of experiment class.\n\n    Raises\n    ------\n    AssertError\n        If `ids` list is empty.\n\n    \"\"\"\n\n    assert ids, \"ids must be specified\"\n    return cls._get_many(ids, project_id=project_id)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"comboboxentry/#furthrmind.collection.comboboxentry.ComboBoxEntry.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"datatable/","title":"DataTable","text":""},{"location":"datatable/#furthrmind.collection.datatable.DataTable","title":"<code>DataTable</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the datatable</p> <code>name</code> <code>str</code> <p>name of the datatable</p> <code>columns</code> <code>List[Column]</code> <p>List of Column objects belonging to this datatable. For additional information, consult the Column documentation. Initially, the columns only present the id and name. To retrieve their values, utilize the get() method on the relevant column or invoke the get_columns() method of the datatable.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>class DataTable(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the datatable\n    name : str\n        name of the datatable\n    columns : List[Column]\n        List of [Column](column.md) objects belonging to this datatable. For additional information, consult the\n        [Column](column.md) documentation. Initially, the columns only present the id and name. To retrieve their\n        values, utilize the get() method on the relevant column or invoke the get_columns() method of the datatable.\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    columns: List[\"Column\"] = []\n\n    _attr_definition = {\n        \"columns\": {\"class\": \"Column\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = DataTable.fm.get_project_url(project_id)\n        url = f\"{project_url}/rawdata/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/rawdata/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/rawdata\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/rawdata\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        This method retrieves a singular `datatable` using its ID. If this method is invoked on an instance of the class,\n        the instance's ID is utilized. The retrieved `datatable` contains columns identified solely by their respective\n        IDs and names. To obtain the corresponding data for these columns, you must either:\n        1. Invoke the `get()` method on the specific column, or\n        2. call the `get_columns()` method on the `datatable`.\n\n        Parameters\n        ----------\n        id : str\n            id of the requested datatable, if\n        project_id : str, optional\n            Optionally, to get experiments from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of the datatable class\n\n        Raises\n        ------\n        AssertionError\n            If used as class method and id not specified\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id, \"id must be specified\"\n        return cls.get(id, project_id=project_id)\n\n    # noinspection PyMethodOverriding\n    @classmethod\n    def get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get many datatables belonging to one project\n        Columns are retrieved with id and column names only. To get the belonging data, the get method of the\n        corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be\n        called\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of ids.\n        project_id : str, optional\n            Optionally to get datatables from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If ids is not specified.\n        \"\"\"\n        pass\n\n        assert ids, \"ids must be specified\"\n        return cls._get_many(ids, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n\n        \"\"\"\n        Method to get all datatables belonging to one project\n        Columns are retrieved with id and column names only. To get the belonging data, the get method of the\n        corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be\n        called\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get datatables from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instances of the DataTable class\n\n        \"\"\"\n        return cls._get_all(project_id=project_id)\n\n    def get_columns(self, column_id_list: List[str] = (), column_name_list: List[str] = ()) -&gt; List[\"Column\"]:\n        \"\"\"\n        Method to get columns and their data belonging to this datatable\n        If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging\n        to the datatable\n        Updates the columns attribute of the datatable for the retrieved columns that belong to this datatable\n\n        Parameters\n        ----------\n        column_id_list : List[str], optional\n            A list of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n        column_name_list : List[str], optional\n            A list of column names to retrieve.\n\n        Returns\n        -------\n        List[\"Column\"]\n            A list of column objects.\n\n        \"\"\"\n\n        columns = self._get_columns(column_id_list, column_name_list)\n        new_column_mapping = {c.id: c for c in columns}\n        new_column_list = []\n        for column in self.columns:\n            if column.id in new_column_mapping:\n                new_column_list.append(new_column_mapping[column.id])\n            else:\n                new_column_list.append(column)\n        self.columns = new_column_list\n        return columns\n\n    def get_pandas_dataframe(self, column_id_list: List[str] = (), column_name_list: List[str] = ()) -&gt; DataFrame:\n        \"\"\"\n        Method to get columns and their data as a pandas dataframe\n        If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging\n        to the datatable\n\n        Parameters\n        ----------\n        column_id_list : List[str]\n            List of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n        column_name_list : List[str]\n            List of column names to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n\n        Returns\n        -------\n        pandas.core.frame.DataFrame\n            Pandas dataframe containing the columns and their data.\n\n        \"\"\"\n\n        columns = self._get_columns(column_id_list, column_name_list)\n        data_dict = {}\n        for c in columns:\n            data_dict[c.name] = c.values\n        df = DataFrame.from_dict(data_dict)\n        return df\n\n    def _get_columns(self, column_id_list: List[str] = None, column_name_list: List[str] = None) -&gt; List[\"Column\"]:\n        from furthrmind.collection import Column\n        if column_id_list:\n            column_id_list_new = []\n            current_column_ids = [c.id for c in self.columns]\n            for column_id in column_id_list:\n                if column_id in current_column_ids:\n                    column_id_list_new.append(column_id)\n            column_id_list = column_id_list_new\n        elif column_name_list:\n            column_id_list = []\n            for column in self.columns:\n                if column.name in column_name_list:\n                    column_id_list.append(column.id)\n        else:\n            column_id_list = [c.id for c in self.columns]\n        columns = Column.get_many(ids=column_id_list)\n        return columns\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str = \"Data table\", experiment_id: str = \"\", sample_id: str = \"\", researchitem_id: str = \"\",\n               columns: List[dict] = (), project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Parameters\n        ----------\n        name: str\n            Name of the datatable.\n        experiment_id: str\n            ID of the experiment where the datatable belongs to.\n        sample_id: str\n            ID of the sample where the datatable belongs to.\n        researchitem_id: str\n            ID of the researchitem where the datatable belongs to.\n        columns: List[dict]\n            A list of columns that should be added to the datatable. List with dicts with the following keys:\n            - name: name of the column\n            - type: Type of the column, Either \"Text\" or \"Numeric\". Data must fit to type, for Text all data will be converted\n              to string and for Numeric all data is converted to float (if possible)\n            - data: List of column values, must fit to column_type, can also be a pandas data series\n            - unit: dict with id or name, or name as string, or id as string\n        project_id: str\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of datatable class.\n\n        Raises\n        ------\n        AssertionError\n            If name is not provided.\n            If experiment_id nor sample_id nor researchitem_id is not provided.\n        \"\"\"\n\n        from furthrmind.collection import Column\n\n        assert name, \"Name must be specified\"\n        assert experiment_id or sample_id or researchitem_id, \"Either experiment_id or sample_id or researchitem_id must be specified\"\n\n        column_id_list = []\n        if columns:\n            columns = Column.create_many(columns)\n            column_id_list = [c.id for c in columns]\n\n        data = {\"name\": name}\n        if column_id_list:\n            data[\"columns\"] = [{\"id\": column_id} for column_id in column_id_list]\n\n        if experiment_id:\n            data[\"experiment\"] = {\"id\": experiment_id}\n\n        if sample_id:\n            data[\"sample\"] = {\"id\": sample_id}\n\n        if researchitem_id:\n            data[\"researchitem\"] = {\"id\": researchitem_id}\n\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.create","title":"<code>create(name='Data table', experiment_id='', sample_id='', researchitem_id='', columns=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the datatable.</p> <code>'Data table'</code> <code>experiment_id</code> <code>str</code> <p>ID of the experiment where the datatable belongs to.</p> <code>''</code> <code>sample_id</code> <code>str</code> <p>ID of the sample where the datatable belongs to.</p> <code>''</code> <code>researchitem_id</code> <code>str</code> <p>ID of the researchitem where the datatable belongs to.</p> <code>''</code> <code>columns</code> <code>List[dict]</code> <p>A list of columns that should be added to the datatable. List with dicts with the following keys: - name: name of the column - type: Type of the column, Either \"Text\" or \"Numeric\". Data must fit to type, for Text all data will be converted   to string and for Numeric all data is converted to float (if possible) - data: List of column values, must fit to column_type, can also be a pandas data series - unit: dict with id or name, or name as string, or id as string</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of datatable class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If name is not provided. If experiment_id nor sample_id nor researchitem_id is not provided.</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str = \"Data table\", experiment_id: str = \"\", sample_id: str = \"\", researchitem_id: str = \"\",\n           columns: List[dict] = (), project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Parameters\n    ----------\n    name: str\n        Name of the datatable.\n    experiment_id: str\n        ID of the experiment where the datatable belongs to.\n    sample_id: str\n        ID of the sample where the datatable belongs to.\n    researchitem_id: str\n        ID of the researchitem where the datatable belongs to.\n    columns: List[dict]\n        A list of columns that should be added to the datatable. List with dicts with the following keys:\n        - name: name of the column\n        - type: Type of the column, Either \"Text\" or \"Numeric\". Data must fit to type, for Text all data will be converted\n          to string and for Numeric all data is converted to float (if possible)\n        - data: List of column values, must fit to column_type, can also be a pandas data series\n        - unit: dict with id or name, or name as string, or id as string\n    project_id: str\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of datatable class.\n\n    Raises\n    ------\n    AssertionError\n        If name is not provided.\n        If experiment_id nor sample_id nor researchitem_id is not provided.\n    \"\"\"\n\n    from furthrmind.collection import Column\n\n    assert name, \"Name must be specified\"\n    assert experiment_id or sample_id or researchitem_id, \"Either experiment_id or sample_id or researchitem_id must be specified\"\n\n    column_id_list = []\n    if columns:\n        columns = Column.create_many(columns)\n        column_id_list = [c.id for c in columns]\n\n    data = {\"name\": name}\n    if column_id_list:\n        data[\"columns\"] = [{\"id\": column_id} for column_id in column_id_list]\n\n    if experiment_id:\n        data[\"experiment\"] = {\"id\": experiment_id}\n\n    if sample_id:\n        data[\"sample\"] = {\"id\": sample_id}\n\n    if researchitem_id:\n        data[\"researchitem\"] = {\"id\": researchitem_id}\n\n    id = cls._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.get","title":"<code>get(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>This method retrieves a singular <code>datatable</code> using its ID. If this method is invoked on an instance of the class, the instance's ID is utilized. The retrieved <code>datatable</code> contains columns identified solely by their respective IDs and names. To obtain the corresponding data for these columns, you must either: 1. Invoke the <code>get()</code> method on the specific column, or 2. call the <code>get_columns()</code> method on the <code>datatable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the requested datatable, if</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally, to get experiments from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the datatable class</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If used as class method and id not specified</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    This method retrieves a singular `datatable` using its ID. If this method is invoked on an instance of the class,\n    the instance's ID is utilized. The retrieved `datatable` contains columns identified solely by their respective\n    IDs and names. To obtain the corresponding data for these columns, you must either:\n    1. Invoke the `get()` method on the specific column, or\n    2. call the `get_columns()` method on the `datatable`.\n\n    Parameters\n    ----------\n    id : str\n        id of the requested datatable, if\n    project_id : str, optional\n        Optionally, to get experiments from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of the datatable class\n\n    Raises\n    ------\n    AssertionError\n        If used as class method and id not specified\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id, \"id must be specified\"\n    return cls.get(id, project_id=project_id)\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all datatables belonging to one project Columns are retrieved with id and column names only. To get the belonging data, the get method of the corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be called</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get datatables from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instances of the DataTable class</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n\n    \"\"\"\n    Method to get all datatables belonging to one project\n    Columns are retrieved with id and column names only. To get the belonging data, the get method of the\n    corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be\n    called\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get datatables from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instances of the DataTable class\n\n    \"\"\"\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.get_columns","title":"<code>get_columns(column_id_list=(), column_name_list=())</code>","text":"<p>Method to get columns and their data belonging to this datatable If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging to the datatable Updates the columns attribute of the datatable for the retrieved columns that belong to this datatable</p> <p>Parameters:</p> Name Type Description Default <code>column_id_list</code> <code>List[str]</code> <p>A list of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.</p> <code>()</code> <code>column_name_list</code> <code>List[str]</code> <p>A list of column names to retrieve.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[Column]</code> <p>A list of column objects.</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>def get_columns(self, column_id_list: List[str] = (), column_name_list: List[str] = ()) -&gt; List[\"Column\"]:\n    \"\"\"\n    Method to get columns and their data belonging to this datatable\n    If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging\n    to the datatable\n    Updates the columns attribute of the datatable for the retrieved columns that belong to this datatable\n\n    Parameters\n    ----------\n    column_id_list : List[str], optional\n        A list of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n    column_name_list : List[str], optional\n        A list of column names to retrieve.\n\n    Returns\n    -------\n    List[\"Column\"]\n        A list of column objects.\n\n    \"\"\"\n\n    columns = self._get_columns(column_id_list, column_name_list)\n    new_column_mapping = {c.id: c for c in columns}\n    new_column_list = []\n    for column in self.columns:\n        if column.id in new_column_mapping:\n            new_column_list.append(new_column_mapping[column.id])\n        else:\n            new_column_list.append(column)\n    self.columns = new_column_list\n    return columns\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.get_many","title":"<code>get_many(ids=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get many datatables belonging to one project Columns are retrieved with id and column names only. To get the belonging data, the get method of the corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be called</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of ids.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get datatables from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If ids is not specified.</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get many datatables belonging to one project\n    Columns are retrieved with id and column names only. To get the belonging data, the get method of the\n    corresponding column must be called. Alternatively, the 'get_columns' method of the datatable must be\n    called\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of ids.\n    project_id : str, optional\n        Optionally to get datatables from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If ids is not specified.\n    \"\"\"\n    pass\n\n    assert ids, \"ids must be specified\"\n    return cls._get_many(ids, project_id=project_id)\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.get_pandas_dataframe","title":"<code>get_pandas_dataframe(column_id_list=(), column_name_list=())</code>","text":"<p>Method to get columns and their data as a pandas dataframe If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging to the datatable</p> <p>Parameters:</p> Name Type Description Default <code>column_id_list</code> <code>List[str]</code> <p>List of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.</p> <code>()</code> <code>column_name_list</code> <code>List[str]</code> <p>List of column names to retrieve. If not provided, all columns belonging to the datatable will be retrieved.</p> <code>()</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe containing the columns and their data.</p> Source code in <code>furthrmind/collection/datatable.py</code> <pre><code>def get_pandas_dataframe(self, column_id_list: List[str] = (), column_name_list: List[str] = ()) -&gt; DataFrame:\n    \"\"\"\n    Method to get columns and their data as a pandas dataframe\n    If column_id_list and column_name_list are not provided, the method will retrieve all columns belonging\n    to the datatable\n\n    Parameters\n    ----------\n    column_id_list : List[str]\n        List of column IDs to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n    column_name_list : List[str]\n        List of column names to retrieve. If not provided, all columns belonging to the datatable will be retrieved.\n\n    Returns\n    -------\n    pandas.core.frame.DataFrame\n        Pandas dataframe containing the columns and their data.\n\n    \"\"\"\n\n    columns = self._get_columns(column_id_list, column_name_list)\n    data_dict = {}\n    for c in columns:\n        data_dict[c.name] = c.values\n    df = DataFrame.from_dict(data_dict)\n    return df\n</code></pre>"},{"location":"datatable/#furthrmind.collection.datatable.DataTable.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"experiment/","title":"Experiment","text":""},{"location":"experiment/#furthrmind.collection.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code>, <code>BaseClassWithFiles</code>, <code>BaseClassWithGroup</code>, <code>BaseClassWithLinking</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the experiment</p> <code>name</code> <code>str</code> <p>name of the experiment</p> <code>shortid</code> <code>str</code> <p>shortid of the experiment</p> <code>files</code> <code>List[File]</code> <p>List of files belonging to this experiment. See File for more information.</p> <code>fielddata</code> <code>List[FieldData]</code> <p>List of field data belonging to this experiment. See FieldData for more information.</p> <code>linked_samples</code> <code>List[Sample]</code> <p>This list contains 'sample' objects linked to the current experiment. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'sample' objects, see the provided Sample.</p> <code>linked_experiments</code> <code>List[Experiment]</code> <p>This list contains 'experiment' objects linked to the current experiment. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'experiment' objects, see the provided Experiment.</p> <code>linked_researchitems</code> <code>Dict[str, List[ResearchItem]]</code> <p>This is a dictionary with category name as keys and lists with the corresponding <code>researchitem</code> objects as values. The <code>researchitem</code> objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'researchitem' objects, see the provided ResearchItem.</p> <code>groups</code> <code>List[Group]</code> <p>This list contains 'group' objects the experiment belongs to. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>datatables</code> <code>List[DataTable]</code> <p>This list contains 'datatable' objects that belong to this experiment. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'datatable' objects, see the provided DataTable.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>class Experiment(BaseClassWithFieldData, BaseClassWithFiles,\n                 BaseClassWithGroup, BaseClassWithLinking):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the experiment\n    name : str\n        name of the experiment\n    shortid : str\n        shortid of the experiment\n    files : List[File]\n        List of files belonging to this experiment. See [File](file.md) for more information.\n    fielddata : List[FieldData]\n        List of field data belonging to this experiment. See [FieldData](fielddata.md) for more information.\n    linked_samples : List[Sample]\n        This list contains 'sample' objects linked to the current experiment. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'sample' objects, see the provided [Sample](sample.md).\n    linked_experiments : List[Experiment]\n        This list contains 'experiment' objects linked to the current experiment. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'experiment' objects, see the provided [Experiment](experiment.md).\n    linked_researchitems : Dict[str, List[ResearchItem]]\n        This is a dictionary with category name as keys and lists with the corresponding `researchitem` objects as values.\n        The `researchitem` objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'researchitem' objects, see the provided [ResearchItem](researchitem.md).\n    groups : List[Group]\n        This list contains 'group' objects the experiment belongs to. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    datatables : List[DataTable]\n        This list contains 'datatable' objects that belong to this experiment. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'datatable' objects, see the provided [DataTable](datatable.md).\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n\n    \"\"\"\n    id = \"\"\n    name = \"\"\n    neglect = False\n    shortid = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n    linked_samples: List[\"Sample\"] = []\n    linked_experiments: List[Self] = []\n    groups: List[\"Group\"] = []\n    linked_researchitems: Dict[str, List[\"ResearchItem\"]] = []\n    datatables: List[\"DataTable\"] = []\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"},\n        \"linked_samples\": {\"class\": \"Sample\"},\n        \"linked_experiments\": {\"class\": \"Experiment\"},\n        \"groups\": {\"class\": \"Group\"},\n        \"linked_researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"datatables\": {\"class\": \"DataTable\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Experiment.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id: str = None) -&gt; str:\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/experiments\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = None, name: str = None, shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get one experiment by its id, name, or short_id\n        If called on an instance of the class, the id of the class is used\n\n        Parameters\n        ----------\n        id : str, optional\n            The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.\n        name : str, optional\n            The name of the experiment to retrieve.\n        shortid : str, optional\n            The short ID of the experiment to retrieve.\n        project_id : str, optional\n            Optionally to get an experiment from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            An instance of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If neither ID nor name nor shortid is specified.\n\n        Example usage:\n            experiment = Experiment.get(id='ex123')\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name or shortid, \"Either id, name, or shortid must be specified\"\n\n        return cls._get(id, shortid, name, project_id=project_id)\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; \\\n            List[Self]:\n        \"\"\"\n        Method to get all experiment belonging to one project\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of experiment ids.\n        shortids : List[str]\n            List of experiment short ids.\n        names : List[str]\n            List of experiment names.\n        project_id : str, optional\n            Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If none of the ids, shortids, or names are specified.\n\n        \"\"\"\n\n        assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n        return cls._get_many(ids, shortids, names, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all experiment belonging to one project\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the experiment class.\n        \"\"\"\n\n        return cls._get_all(project_id=project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, group_name: str = \"\", group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to create a new experiment\n\n        Parameters\n        ----------\n        name : str\n            The name of the item to be created\n        group_name : str, optional\n            The name of the group where the new item will belong to. Group name can be only considered for groups that\n            are not subgroups. Either group_name or group_id must be specified.\n        group_id : str, optional\n            The id of the group where the new item will belong to. Either group_name or group_id must be specified.\n        project_id : str, optional\n            Optionally, to create an item in another project as the furthrmind sdk was initiated with.\n\n        Returns\n        -------\n        Experiment instance\n            The instance of the experiment class created.\n\n        \"\"\"\n\n        return cls._create(name, group_name, group_id, project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Parameters\n        ----------\n        data_list : List[Dict]\n            List of dictionaries containing information about the experiments to be created.\n            Each dictionary should have the following keys:\n\n            - name: str\n                The name of the experiment.\n            - group_name : str\n                The name of the group where the experiment will belong to.\n                Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.\n            - group_id : str\n                The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.\n\n        project_id : str, optional\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        \"\"\"\n\n        return cls._create_many(data_list, project_id)\n\n    def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\") -&gt; \"DataTable\":\n        \"\"\"\n        Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute\n\n        Parameters\n        ----------\n        name : str\n            Name of the datatable.\n        columns : List[Dict]\n            A list of columns that should be added to the datatable. Each column is represented as a dictionary with the\n            following keys:\n\n            - name : str\n                Name of the column.&lt;/br&gt;\n            - type : str\n                Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n            - data : Union[List[Union[str, float]], pandas.Series]\n                List of column values. Data must fit the specified type of the column.\n                For Text columns, the items must be convertable to strings\n                For Numeric columns, the items must be convertable to floats.\n                Can be a list or a pandas.Series.\n            - unit : dict or str\n                Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n                representing the name or id of the unit.\n        project_id : str, optional\n            Optionally, specify the id of another project to create the datatable in.\n\n        Returns\n        -------\n        DataTable\n            An instance of the DataTable class representing the created datatable.\n\n        \"\"\"\n\n        from furthrmind.collection import DataTable\n        datatable = DataTable.create(name, experiment_id=self.id, columns=columns, project_id=project_id)\n\n        new_datatables = list(self.datatables)\n        new_datatables.append(datatable)\n        self.datatables = new_datatables\n\n        return datatable\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_datatable","title":"<code>add_datatable(name, columns, project_id='')</code>","text":"<p>Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the datatable.</p> required <code>columns</code> <code>List[Dict]</code> <p>A list of columns that should be added to the datatable. Each column is represented as a dictionary with the following keys:</p> <ul> <li>name : str     Name of the column.</li> <li>type : str     Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.</li> <li>data : Union[List[Union[str, float]], pandas.Series]     List of column values. Data must fit the specified type of the column.     For Text columns, the items must be convertable to strings     For Numeric columns, the items must be convertable to floats.     Can be a list or a pandas.Series.</li> <li>unit : dict or str     Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string     representing the name or id of the unit.</li> </ul> required <code>project_id</code> <code>str</code> <p>Optionally, specify the id of another project to create the datatable in.</p> <code>''</code> <p>Returns:</p> Type Description <code>DataTable</code> <p>An instance of the DataTable class representing the created datatable.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\") -&gt; \"DataTable\":\n    \"\"\"\n    Method to create a new datatable within this experiment. Add the created datatable to the datatables attribute\n\n    Parameters\n    ----------\n    name : str\n        Name of the datatable.\n    columns : List[Dict]\n        A list of columns that should be added to the datatable. Each column is represented as a dictionary with the\n        following keys:\n\n        - name : str\n            Name of the column.&lt;/br&gt;\n        - type : str\n            Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n        - data : Union[List[Union[str, float]], pandas.Series]\n            List of column values. Data must fit the specified type of the column.\n            For Text columns, the items must be convertable to strings\n            For Numeric columns, the items must be convertable to floats.\n            Can be a list or a pandas.Series.\n        - unit : dict or str\n            Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n            representing the name or id of the unit.\n    project_id : str, optional\n        Optionally, specify the id of another project to create the datatable in.\n\n    Returns\n    -------\n    DataTable\n        An instance of the DataTable class representing the created datatable.\n\n    \"\"\"\n\n    from furthrmind.collection import DataTable\n    datatable = DataTable.create(name, experiment_id=self.id, columns=columns, project_id=project_id)\n\n    new_datatables = list(self.datatables)\n    new_datatables.append(datatable)\n    self.datatables = new_datatables\n\n    return datatable\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_file","title":"<code>add_file(file_path='', file_name='', file_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path of the file that should be uploaded.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Optionally specify the file name if not the original file name should be used.</p> <code>''</code> <code>file_id</code> <code>str</code> <p>ID of the file.</p> <code>''</code> <p>Returns:</p> Type Description <code>File</code> <p>The file object that has been added.</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If neither file path nor file_id is specified.</p> <code>ValueError</code> <p>If the file path specified does not exist.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_file(self, file_path: str = \"\", file_name: str = \"\", file_id: str = \"\") -&gt; \"File\":\n    \"\"\"\n    Parameters\n    ----------\n    file_path : str, optional\n        File path of the file that should be uploaded.\n    file_name : str, optional\n        Optionally specify the file name if not the original file name should be used.\n    file_id : str, optional\n        ID of the file.\n\n    Returns\n    -------\n    File\n        The file object that has been added.\n\n    Raises\n    ------\n    AssertationError\n        If neither file path nor file_id is specified.\n    ValueError\n        If the file path specified does not exist.\n    \"\"\"\n\n\n    from furthrmind.file_loader import FileLoader\n    from .file import File\n\n    assert file_path or file_id, \"File_path or file_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if not file_id:\n        assert file_path, \"File path must be specified\"\n        if not os.path.isfile(file_path):\n            raise ValueError(\"File does not exist\")\n\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n        file_id, file_name = fl.uploadFile(file_path, file_name)\n        file_data = {\"id\": file_id,\n                     \"name\": file_name}\n    else:\n        file_data = {\"id\": file_id}\n\n    file_list = [{\"id\": f.id} for f in self.files]\n    file_list.append(file_data)\n    post_data = {\"id\": self.id, \"files\": file_list}\n\n    id = self._post(post_data)\n    file = File(data=file_data)\n    new_file_list = list(self.files)\n    new_file_list.append(file)\n    self.files = new_file_list\n    return file\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_linked_experiment","title":"<code>add_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>This method is used to link an experiment to the current item. If the experiment is already linked to the item, no action is taken.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    This method is used to link an experiment to the current item. If the experiment is already linked to the item,\n    no action is taken.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n    experiment_name : str, optional\n        The name of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n\n    Returns\n    -------\n    str\n        The ID of the item.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name=experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n    else:\n        exp = Experiment.get(experiment_id)\n\n    experiment_id_list = [item.id for item in self.linked_experiments]\n    if experiment_id in experiment_id_list:\n        return self.id\n\n    experiment_id_list.append(experiment_id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    new_linked_experiments = list(self.linked_experiments)\n    new_linked_experiments.append(exp)\n    self.linked_experiments = new_linked_experiments\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_linked_researchitem","title":"<code>add_linked_researchitem(researchitem_id)</code>","text":"<p>Method is to link a research item to the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The id of the research item to be linked. If not specified, the method will raise an assertion error.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The id of the current research item.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If researchitem_id is not specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method is to link a research item to the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The id of the research item to be linked. If not specified, the method will raise an assertion error.\n\n    Returns\n    -------\n    str\n        The id of the current research item.\n\n    Raises\n    ------\n    AssertionError\n        If researchitem_id is not specified.\n\n    \"\"\"\n\n    from furthrmind.collection import ResearchItem\n    assert researchitem_id, \"researchitem_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    for cat in self.linked_researchitems:\n        researchitem_id_list.extend([ri_id.id for ri_id in self.linked_researchitems[cat]])\n\n    if researchitem_id in researchitem_id_list:\n        return self.id\n\n    researchitem_id_list.append(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    ri = ResearchItem.get(id=researchitem_id)\n    research_item_dict = dict(self.linked_researchitems)\n    if ri.category.name in self.linked_researchitems:\n        new_linked_researchitems = list(self.linked_researchitems[ri.category.name])\n    else:\n        new_linked_researchitems = []\n\n    new_linked_researchitems.append(ri)\n    research_item_dict[ri.category.name] = new_linked_researchitems\n    self.linked_researchitems = research_item_dict\n\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_linked_sample","title":"<code>add_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to link a sample to the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>id to the sample you want to link, either id or name must be given</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>name of the sample you want to link, either name or id must be given</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the id of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample found with the given name</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to link a sample to the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        id to the sample you want to link, either id or name must be given\n    sample_name : str, optional\n        name of the sample you want to link, either name or id must be given\n\n    Returns\n    -------\n    str\n        the id of the item\n\n    Raises\n    ------\n    ValueError\n        If no sample found with the given name\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n    else:\n        s = Sample.get(sample_id)\n\n    sample_id_list = [item.id for item in self.linked_samples]\n    if sample_id in sample_id_list:\n        return self.id\n\n    sample_id_list.append(sample_id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n\n    self._post(data=data)\n    new_linked_samples = list(self.linked_samples)\n    new_linked_samples.append(s)\n    self.linked_samples = new_linked_samples\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.create","title":"<code>create(name, group_name='', group_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create a new experiment</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to be created</p> required <code>group_name</code> <code>str</code> <p>The name of the group where the new item will belong to. Group name can be only considered for groups that are not subgroups. Either group_name or group_id must be specified.</p> <code>''</code> <code>group_id</code> <code>str</code> <p>The id of the group where the new item will belong to. Either group_name or group_id must be specified.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally, to create an item in another project as the furthrmind sdk was initiated with.</p> <code>''</code> <p>Returns:</p> Type Description <code>Experiment instance</code> <p>The instance of the experiment class created.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, group_name: str = \"\", group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to create a new experiment\n\n    Parameters\n    ----------\n    name : str\n        The name of the item to be created\n    group_name : str, optional\n        The name of the group where the new item will belong to. Group name can be only considered for groups that\n        are not subgroups. Either group_name or group_id must be specified.\n    group_id : str, optional\n        The id of the group where the new item will belong to. Either group_name or group_id must be specified.\n    project_id : str, optional\n        Optionally, to create an item in another project as the furthrmind sdk was initiated with.\n\n    Returns\n    -------\n    Experiment instance\n        The instance of the experiment class created.\n\n    \"\"\"\n\n    return cls._create(name, group_name, group_id, project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing information about the experiments to be created. Each dictionary should have the following keys:</p> <ul> <li>name: str     The name of the experiment.</li> <li>group_name : str     The name of the group where the experiment will belong to.     Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.</li> <li>group_id : str     The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.</li> </ul> required <code>project_id</code> <code>str</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Parameters\n    ----------\n    data_list : List[Dict]\n        List of dictionaries containing information about the experiments to be created.\n        Each dictionary should have the following keys:\n\n        - name: str\n            The name of the experiment.\n        - group_name : str\n            The name of the group where the experiment will belong to.\n            Only applicable for groups that are not subgroups. Either group_name or group_id must be specified.\n        - group_id : str\n            The ID of the group where the experiment will belong to. Either group_name or group_id must be specified.\n\n    project_id : str, optional\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    \"\"\"\n\n    return cls._create_many(data_list, project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.get","title":"<code>get(id=None, name=None, shortid='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one experiment by its id, name, or short_id If called on an instance of the class, the id of the class is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the experiment to retrieve.</p> <code>None</code> <code>shortid</code> <code>str</code> <p>The short ID of the experiment to retrieve.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get an experiment from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither ID nor name nor shortid is specified.</p> <code>Example usage:</code> <p>experiment = Experiment.get(id='ex123')</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get(cls, id: str = None, name: str = None, shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get one experiment by its id, name, or short_id\n    If called on an instance of the class, the id of the class is used\n\n    Parameters\n    ----------\n    id : str, optional\n        The ID of the experiment to retrieve. If not provided, the ID of the calling instance will be used.\n    name : str, optional\n        The name of the experiment to retrieve.\n    shortid : str, optional\n        The short ID of the experiment to retrieve.\n    project_id : str, optional\n        Optionally to get an experiment from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        An instance of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If neither ID nor name nor shortid is specified.\n\n    Example usage:\n        experiment = Experiment.get(id='ex123')\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name or shortid, \"Either id, name, or shortid must be specified\"\n\n    return cls._get(id, shortid, name, project_id=project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all experiment belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get experiments from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list containing instances of the experiment class.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all experiment belonging to one project\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list containing instances of the experiment class.\n    \"\"\"\n\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.get_many","title":"<code>get_many(ids=(), shortids=(), names=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all experiment belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of experiment ids.</p> <code>()</code> <code>shortids</code> <code>List[str]</code> <p>List of experiment short ids.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of experiment names.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get experiments from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If none of the ids, shortids, or names are specified.</p> Source code in <code>furthrmind/collection/experiment.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; \\\n        List[Self]:\n    \"\"\"\n    Method to get all experiment belonging to one project\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of experiment ids.\n    shortids : List[str]\n        List of experiment short ids.\n    names : List[str]\n        List of experiment names.\n    project_id : str, optional\n        Optionally to get experiments from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If none of the ids, shortids, or names are specified.\n\n    \"\"\"\n\n    assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n    return cls._get_many(ids, shortids, names, project_id=project_id)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.remove_file","title":"<code>remove_file(file_id='', file_name='')</code>","text":"<p>Method to remove a file from the current item</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>str</code> <p>ID of the file that should be removed. Either <code>file_id</code> or <code>file_name</code> must be specified.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be removed.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>file_object</code> <code>dict</code> <p>Object representing the removed file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no file is found with the given <code>file_id</code> or <code>file_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_file(self, file_id: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Method to remove a file from the current item\n\n    Parameters\n    ----------\n    file_id: str, optional\n        ID of the file that should be removed. Either `file_id` or `file_name` must be specified.\n    file_name: str, optional\n        Name of the file to be removed.\n\n    Returns\n    -------\n    file_object: dict\n        Object representing the removed file.\n\n    Raises\n    ------\n    ValueError\n        If no file is found with the given `file_id` or `file_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    new_file_list = []\n    file_to_be_removed = None\n    for file in self.files:\n        found = False\n        if file_id:\n            found = True\n            if file.id == file_id:\n                file_to_be_removed = file\n        elif file_name:\n            found = True\n            if file.name == file_name:\n                file_to_be_removed = file\n        if not found:\n            new_file_list.append(file)\n\n    if not file_to_be_removed:\n        raise ValueError(\"No file found with the given file_id or file_name\")\n\n    self.files = new_file_list\n    file_list = [{\"id\": f.id} for f in new_file_list]\n    post_data = {\"id\": self.id, \"files\": file_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.remove_linked_experiment","title":"<code>remove_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>Method to remove a linked experiment from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> <code>AssertionError</code> <p>If neither <code>experiment_id</code> nor <code>experiment_name</code> is specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    Method to remove a linked experiment from the current item.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n    experiment_name : str, optional\n        The name of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n    AssertionError\n        If neither `experiment_id` nor `experiment_name` is specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name = experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n\n    experiment_id_list = []\n    new_linked_items = []\n    for item in self.linked_experiments:\n        if item.id == experiment_id:\n            continue\n        new_linked_items.append(item)\n        experiment_id_list.append(item.id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    self.linked_experiments = new_linked_items\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.remove_linked_researchitem","title":"<code>remove_linked_researchitem(researchitem_id)</code>","text":"<p>Method to remove a linked researchitem from the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The ID of the research item you want to unlink</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method to remove a linked researchitem from the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The ID of the research item you want to unlink\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n    \"\"\"\n\n    assert researchitem_id, \"Either experiment_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    new_linked_items = {}\n    for cat in self.linked_researchitems:\n        for item in self.linked_researchitems[cat]:\n            if item.id == researchitem_id:\n                continue\n            if cat not in new_linked_items:\n                new_linked_items[cat] = []\n            new_linked_items[cat].append(item)\n            researchitem_id_list.append(item.id)\n\n    if researchitem_id in researchitem_id_list:\n        researchitem_id_list.remove(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    self.linked_researchitems = new_linked_items\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.remove_linked_sample","title":"<code>remove_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to remove a linked sample from the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>The id of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>The name of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample is found with the given name.</p> Notes <p>This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to remove a linked sample from the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        The id of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n    sample_name : str, optional\n        The name of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n\n    Returns\n    -------\n    str\n        The id of the item.\n\n    Raises\n    ------\n    ValueError\n        If no sample is found with the given name.\n\n    Notes\n    -----\n    This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n\n    sample_id_list = []\n    new_linked_items = []\n    for item in self.linked_samples:\n        if item.id == sample_id:\n            continue\n        new_linked_items.append(item)\n        sample_id_list.append(item.id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n    self._post(data=data)\n    self.linked_samples = new_linked_items\n    return self.id\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"experiment/#furthrmind.collection.experiment.Experiment.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"field/","title":"Field","text":""},{"location":"field/#furthrmind.collection.field.Field","title":"<code>Field</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the field</p> <code>name</code> <code>str</code> <p>name of the field</p> <code>type</code> <code>str</code> <p>Corresponding field type. One out of:</p> <pre><code>- Numeric for numeric fields\n- Date for date fields\n- SingleLine for text fields\n- ComboBox for list fields\n- MultiLine for notebook fields\n- Checkbox for checkbox fields\n- Calculation for calculation fields\n</code></pre> <code>script</code> <code>str</code> <p>In case of a calculation field, this attribute holds the script applied for the calculations</p> <code>comboboxentries</code> <code>List[ComboBoxEntry]</code> <p>In case of a list field, this attribute holds all attached list options as ComboBoxEntry objects. Otherwise it is an empty list.</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>class Field(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the field\n    name : str\n        name of the field\n    type : str\n        Corresponding field type. One out of:\n\n            - Numeric for numeric fields\n            - Date for date fields\n            - SingleLine for text fields\n            - ComboBox for list fields\n            - MultiLine for notebook fields\n            - Checkbox for checkbox fields\n            - Calculation for calculation fields\n\n    script : str\n        In case of a calculation field, this attribute holds the script applied for the calculations\n    comboboxentries : List[ComboBoxEntry]\n        In case of a list field, this attribute holds all attached list options as [ComboBoxEntry](comboboxentry.md)\n        objects. Otherwise it is an empty list.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    type = \"\"\n    script = \"\"\n    comboboxentries: List[\"ComboBoxEntry\"] = []\n\n    _attr_definition = {\n        \"comboboxentries\": {\"class\": \"ComboBoxEntry\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Field.fm.get_project_url(project_id)\n        url = f\"{project_url}/fields/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/fields/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/fields\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/fields\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", name: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get all one field by its id or name\n        If called on the instance of a class, the id of the instance is used\n\n        Parameters\n        ----------\n        id : str\n            id of the requested field\n        name : str\n            name of the requested field\n        project_id : str, optional\n            Optionally to get a field from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of the field class\n\n        Raises\n        ------\n        AssertionError\n            If called as class method and neither id nor name is specified\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name, \"Either id or name must be specified\"\n        return cls._get(id, name=name, project_id=project_id)\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get many fields belonging to one project\n\n        Parameters\n        ----------\n        ids : list of str, optional\n            List of ids to get fields for.\n\n        names : list of str, optional\n            List of names to get fields for.\n\n        project_id : str, optional\n            Optionally to get fields from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        list[Self]\n            List of instances of the experiment class.\n\n        Raises\n        ------\n        AssertionError\n            If neither ids nor names are specified.\n\n        \"\"\"\n\n        assert ids or names, \"Either ids or names must be specified\"\n        return cls._get_many(ids, names=names, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all fields belonging to one project\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get fields from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instances of the field class, representing all the fields belonging to the specified project.\n        \"\"\"\n\n        return cls._get_all(project_id=project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, type: str, project_id: str = \"\") -&gt; Self:\n\n        \"\"\"\n        Method to create a new field\n\n        Parameters\n        ----------\n        name : str\n            The name of the field to be created.\n        type : str\n            The field type of the field. Must be one of the following. Lower or uppercase is not considered,\n                i.e. Numeric or numeric is both valid:\n                - Numeric fields: numeric, numeric-field, numeric_field\n                - Date fields: date, date_field, date-field, datefield\n                - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n                - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n                - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n                - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n                - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n        project_id : str, optional\n            Optionally, the ID of the project to create an item in. If not provided, the item will be created in the project associated with the furthrmind SDK.\n\n        Returns\n        -------\n        instance of the sample class\n            The created sample instance.\n\n        Raises\n        ------\n        ValueError\n            If name is empty or if type is not one of the allowed types.\n\n        \"\"\"\n\n        if not name:\n            raise ValueError(\"Name cannot be empty\")\n\n        type = cls._check_field_type(type)\n        data = {\"name\": name, \"type\": type}\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    def _check_field_type(cls, field_type: str):\n        field_type_mapping = {\n            \"Numeric\": [\"numeric\", \"numeric-field\", \"numeric_field\", \"numericfield\"],\n            \"Date\": [\"date\", \"date_field\", \"date-field\", \"datefield\"],\n            \"SingleLine\": [\"singleline\", \"single-line\", \"single_line\", \"singlelinefield\", \"single-line-field\",\n                           \"single_line_field\", \"text\", \"text-field\", \"text_field\", \"textfield\"],\n            \"ComboBox\": [\"combobox\", \"comboboxfield\", \"combobox-field\", \"combobox_field\", \"comboboxentry\",\n                         \"list\", \"listfield\", \"list-field\", \"list_field\"],\n            \"MultiLine\": [\"multiline\", \"multi_line\", \"mulit-line\", \"multilinefield\", \"multi-line-field\",\n                          \"multi_line_field\", \"notebook-field\", \"notebook_field\", \"notebookfield\"],\n            \"CheckBox\": [\"checkbox\", \"checkbox-field\", \"checkbox_field\", \"checkboxfield\"],\n            \"Calculation\": [\"calculation\", \"calculation-field\", \"calculation_field\", \"calculationfield\"],\n        }\n        for field_type_server in field_type_mapping:\n            if field_type.lower() in field_type_mapping[field_type_server]:\n                return field_type_server\n\n        raise ValueError(\"Wrong field type\")\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id=None) -&gt; List[Self]:\n        \"\"\"\n        Method to create multiple fields\n\n        Parameters\n        ----------\n        data_list : List[Dict]\n            A list of dictionaries containing the data for creating multiple samples. Each dictionary should\n            have the following keys:\n            - name : str\n                The name of the field to be created.\n            - type : str\n                The field type of the field. Must be one of the following. Lower or uppercase is not considered,\n                i.e. Numeric or numeric is both valid:\n                - Numeric fields: numeric, numeric-field, numeric_field\n                - Date fields: date, date_field, date-field, datefield\n                - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n                - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n                - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n                - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n                - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n        project_id : int, optional\n            Optionally to create fields in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instance of the field class that have been created.\n\n        Raises\n        ------\n        ValueError\n            When the \"name\" key is missing or empty in any of the dictionaries in data_list.\n        ValueError\n            When the \"type\" value is not one of: Numeric, Date, SingleLine, ComboBox, MultiLine, CheckBox, Calculation.\n\n\n        Examples\n        --------\n        data_list = [\n            {\"name\": \"Field 1\", \"type\": \"Numeric\"},\n            {\"name\": \"Field 2\", \"type\": \"SingleLine\"},\n            {\"name\": \"Field 3\", \"type\": \"Date\"},\n            {\"name\": \"Field 4\", \"type\": \"ComboBox\"},\n        ]\n\n        fields = ClassName.create_many(data_list)\n\n        \"\"\"\n\n        for data in data_list:\n            if not \"name\" in data:\n                raise ValueError(\"Name cannot be empty\")\n\n            field_type = cls._check_field_type(data.get(\"type\"))\n            data[\"type\"] = field_type\n\n        id_list = cls._post(data_list, project_id, force_list=True)\n        for data, id in zip(data_list, id_list):\n            data[\"id\"] = id\n        return data_list\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.create","title":"<code>create(name, type, project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create a new field</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field to be created.</p> required <code>type</code> <code>str</code> <p>The field type of the field. Must be one of the following. Lower or uppercase is not considered,     i.e. Numeric or numeric is both valid:     - Numeric fields: numeric, numeric-field, numeric_field     - Date fields: date, date_field, date-field, datefield     - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield     - List fields: combobox, comboboxfield, list, list-field, list_field, listfield     - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field     - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield     - Calculation fields: calculation, calculation-field, calculation_field, calculationfield</p> required <code>project_id</code> <code>str</code> <p>Optionally, the ID of the project to create an item in. If not provided, the item will be created in the project associated with the furthrmind SDK.</p> <code>''</code> <p>Returns:</p> Type Description <code>instance of the sample class</code> <p>The created sample instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If name is empty or if type is not one of the allowed types.</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, type: str, project_id: str = \"\") -&gt; Self:\n\n    \"\"\"\n    Method to create a new field\n\n    Parameters\n    ----------\n    name : str\n        The name of the field to be created.\n    type : str\n        The field type of the field. Must be one of the following. Lower or uppercase is not considered,\n            i.e. Numeric or numeric is both valid:\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    project_id : str, optional\n        Optionally, the ID of the project to create an item in. If not provided, the item will be created in the project associated with the furthrmind SDK.\n\n    Returns\n    -------\n    instance of the sample class\n        The created sample instance.\n\n    Raises\n    ------\n    ValueError\n        If name is empty or if type is not one of the allowed types.\n\n    \"\"\"\n\n    if not name:\n        raise ValueError(\"Name cannot be empty\")\n\n    type = cls._check_field_type(type)\n    data = {\"name\": name, \"type\": type}\n    id = cls._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.create_many","title":"<code>create_many(data_list, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to create multiple fields</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>A list of dictionaries containing the data for creating multiple samples. Each dictionary should have the following keys: - name : str     The name of the field to be created. - type : str     The field type of the field. Must be one of the following. Lower or uppercase is not considered,     i.e. Numeric or numeric is both valid:     - Numeric fields: numeric, numeric-field, numeric_field     - Date fields: date, date_field, date-field, datefield     - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield     - List fields: combobox, comboboxfield, list, list-field, list_field, listfield     - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field     - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield     - Calculation fields: calculation, calculation-field, calculation_field, calculationfield</p> required <code>project_id</code> <code>int</code> <p>Optionally to create fields in another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instance of the field class that have been created.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the \"name\" key is missing or empty in any of the dictionaries in data_list.</p> <code>ValueError</code> <p>When the \"type\" value is not one of: Numeric, Date, SingleLine, ComboBox, MultiLine, CheckBox, Calculation.</p> <p>Examples:</p> <p>data_list = [     {\"name\": \"Field 1\", \"type\": \"Numeric\"},     {\"name\": \"Field 2\", \"type\": \"SingleLine\"},     {\"name\": \"Field 3\", \"type\": \"Date\"},     {\"name\": \"Field 4\", \"type\": \"ComboBox\"}, ]</p> <p>fields = ClassName.create_many(data_list)</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id=None) -&gt; List[Self]:\n    \"\"\"\n    Method to create multiple fields\n\n    Parameters\n    ----------\n    data_list : List[Dict]\n        A list of dictionaries containing the data for creating multiple samples. Each dictionary should\n        have the following keys:\n        - name : str\n            The name of the field to be created.\n        - type : str\n            The field type of the field. Must be one of the following. Lower or uppercase is not considered,\n            i.e. Numeric or numeric is both valid:\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    project_id : int, optional\n        Optionally to create fields in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instance of the field class that have been created.\n\n    Raises\n    ------\n    ValueError\n        When the \"name\" key is missing or empty in any of the dictionaries in data_list.\n    ValueError\n        When the \"type\" value is not one of: Numeric, Date, SingleLine, ComboBox, MultiLine, CheckBox, Calculation.\n\n\n    Examples\n    --------\n    data_list = [\n        {\"name\": \"Field 1\", \"type\": \"Numeric\"},\n        {\"name\": \"Field 2\", \"type\": \"SingleLine\"},\n        {\"name\": \"Field 3\", \"type\": \"Date\"},\n        {\"name\": \"Field 4\", \"type\": \"ComboBox\"},\n    ]\n\n    fields = ClassName.create_many(data_list)\n\n    \"\"\"\n\n    for data in data_list:\n        if not \"name\" in data:\n            raise ValueError(\"Name cannot be empty\")\n\n        field_type = cls._check_field_type(data.get(\"type\"))\n        data[\"type\"] = field_type\n\n    id_list = cls._post(data_list, project_id, force_list=True)\n    for data, id in zip(data_list, id_list):\n        data[\"id\"] = id\n    return data_list\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.get","title":"<code>get(id='', name='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all one field by its id or name If called on the instance of a class, the id of the instance is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the requested field</p> <code>''</code> <code>name</code> <code>str</code> <p>name of the requested field</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get a field from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the field class</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If called as class method and neither id nor name is specified</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", name: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get all one field by its id or name\n    If called on the instance of a class, the id of the instance is used\n\n    Parameters\n    ----------\n    id : str\n        id of the requested field\n    name : str\n        name of the requested field\n    project_id : str, optional\n        Optionally to get a field from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of the field class\n\n    Raises\n    ------\n    AssertionError\n        If called as class method and neither id nor name is specified\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name, \"Either id or name must be specified\"\n    return cls._get(id, name=name, project_id=project_id)\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all fields belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get fields from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instances of the field class, representing all the fields belonging to the specified project.</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all fields belonging to one project\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get fields from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instances of the field class, representing all the fields belonging to the specified project.\n    \"\"\"\n\n    return cls._get_all(project_id=project_id)\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.get_many","title":"<code>get_many(ids=(), names=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get many fields belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list of str</code> <p>List of ids to get fields for.</p> <code>()</code> <code>names</code> <code>list of str</code> <p>List of names to get fields for.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get fields from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>list[Self]</code> <p>List of instances of the experiment class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither ids nor names are specified.</p> Source code in <code>furthrmind/collection/field.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), names: List[str] = (), project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get many fields belonging to one project\n\n    Parameters\n    ----------\n    ids : list of str, optional\n        List of ids to get fields for.\n\n    names : list of str, optional\n        List of names to get fields for.\n\n    project_id : str, optional\n        Optionally to get fields from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    list[Self]\n        List of instances of the experiment class.\n\n    Raises\n    ------\n    AssertionError\n        If neither ids nor names are specified.\n\n    \"\"\"\n\n    assert ids or names, \"Either ids or names must be specified\"\n    return cls._get_many(ids, names=names, project_id=project_id)\n</code></pre>"},{"location":"field/#furthrmind.collection.field.Field.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"fielddata/","title":"FieldData","text":""},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData","title":"<code>FieldData</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the fielddata</p> <code>field_name</code> <code>str</code> <p>field name of the corresponding field</p> <code>field_id</code> <code>List[File]</code> <p>field id of the corresponding field</p> <code>field_type</code> <code>List[FieldData]</code> <p>field type of the corresponding field</p> <code>value</code> <code>Any</code> <p>value of the fielddata. Type depends on the field type:</p> <pre><code>- Numeric fields: float or None\n- Date fields: python datetime object or None\n- Text field: string or None\n- List field: The value will be a dictionary with the name and the id to the selected option (comboboxentry).\n    If no option is selected, the value will be None\n- Notebook field: The value will be a dictionary with the id and content of the notebook.\n- Checkbox field: boolean\n</code></pre> <code>si_value</code> <code>Union[float, None]</code> <p>In case of numeric fields, the attribute represents the corresponding si-value considering the selected unit</p> <code>unit</code> <code>[Unit](md)</code> <p>The selected unit for numeric fields. Otherwise None</p> <code>author</code> <code>Dict[str, str]</code> <p>The author of the fielddata with id and email address</p> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>class FieldData(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the fielddata\n    field_name : str\n        field name of the corresponding field\n    field_id : List[File]\n        field id of the corresponding field\n    field_type : List[FieldData]\n        field type of the corresponding field\n    value : Any\n        value of the fielddata. Type depends on the field type:\n\n            - Numeric fields: float or None\n            - Date fields: python datetime object or None\n            - Text field: string or None\n            - List field: The value will be a dictionary with the name and the id to the selected option (comboboxentry).\n                If no option is selected, the value will be None\n            - Notebook field: The value will be a dictionary with the id and content of the notebook.\n            - Checkbox field: boolean\n    si_value : Union[float, None]\n        In case of numeric fields, the attribute represents the corresponding si-value considering the selected unit\n    unit : [Unit](unit.md)\n        The selected unit for numeric fields. Otherwise None\n    author: Dict[str, str]\n        The author of the fielddata with id and email address\n\n    \"\"\"\n    id = \"\"\n    field_name = \"\"\n    field_id = \"\"\n    field_type = \"\"\n    si_value = None\n    unit: \"Unit\" = None\n    author = None\n    value = None\n\n    _attr_definition = {\n        \"unit\": {\"class\": \"Unit\"},\n        \"field_name\": {\"data_key\": \"fieldname\"},\n        \"field_type\": {\"data_key\": \"fieldtype\"},\n        \"field_id\": {\"data_key\": \"fieldid\"},\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n        # create instance methods for certain class_methods\n        instance_methods = [\"_check_value_type\"]\n        instance_overload(self, instance_methods)\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/fielddata\"\n        return url\n\n    @classmethod\n    def get(cls, id=None):\n        raise TypeError(\"Not implemented\")\n\n    @classmethod\n    def _get_all(cls, project_id=None):\n        raise TypeError(\"Not implemented\")\n\n    def update_value(self, value) -&gt; str:\n        \"\"\"\n        Parameters\n        ----------\n        value :\n            The value to update the fielddata. The valid types for each field type are as follows:\n\n            - numeric, numeric-field, numeric_field: float or int, or a string convertable to a float\n            - date, date_field, date-field, datefield: datetime, or date object, or unix timestamp or string with\n                iso format\n            - singleline, singlelinefield, text, text-field, text_field, textfield: string\n            - combobox, comboboxfield, list, list-field, list_field, listfield: dict with id or name as key, or string\n                with name, or string with id\n            - multiline, notebook, notebookfield, notebook-field, notebook_field: dict with content as key, or string\n            - checkbox, checkbox-field, checkbox_field, checkboxfield: boolean\n\n        Returns\n        -------\n        id : str\n            The id of the updated fielddata.\n        \"\"\"\n\n        value, field_type = self.__class__._check_value_type(value, self.field_type)\n        data = {\"id\": self.id,\n                \"value\": value}\n        id = self._post(data)\n        self.value = value\n        return id\n\n    def set_calculation_result(self, value: Dict) -&gt; str:\n        \"\"\"\n        Parameters\n        ----------\n        value: dict\n            A dictionary representing the calculation result.\n\n        Raises\n        ------\n        TypeError\n            If the field type is not a calculation\n\n        Returns\n        -------\n        id: str\n            The ID of the calculation field.\n        \"\"\"\n\n        if not self.field_type.lower() in [\"calculation\", \"rawdatacalc\"]:\n            raise TypeError(\"Only applicable for calculation field\")\n\n        url = f\"{self.fm.base_url}/set-result/{self.id}\"\n        response = self.fm.session.post(url, json=value)\n        if response.status_code != 200:\n            raise ValueError(\"Setting calculation result failed\")\n        return self.id\n\n    @classmethod\n    def _check_value_type(cls, value, field_type=None) -&gt; Tuple:\n        from furthrmind.collection import Field\n\n        if issubclass(cls, BaseClass):\n            # classmethod\n            if field_type is None:\n                raise ValueError(\"fieldtype must not be None\")\n        else:\n            # instance method\n            self = cls\n            field_type = self.field_type\n\n        # raises an error or returns: \"Numeric\", \"Date\", \"SingleLine\",\n        # \"ComboBox\", \"MultiLine\", \"CheckBox\", \"Calculation\"\n        field_type = Field._check_field_type(field_type)\n\n        if value is None:\n            return value, field_type\n\n        if field_type == \"Numeric\":\n            try:\n                value = float(value)\n            except:\n                raise TypeError(\"Not numeric\")\n            return value, field_type\n        elif field_type == \"Date\":\n            if isinstance(value, datetime):\n                return int(value.timestamp()), field_type\n            if isinstance(value, date):\n                value = datetime.combine(value, datetime.min.time())\n                return int(value.timestamp()), field_type\n            if isinstance(value, str):\n                try:\n                    value = datetime.fromisoformat(value)\n                    return int(value.timestamp()), field_type\n                except ValueError:\n                    raise TypeError(\"No iso time format\")\n            if isinstance(value, (int, float)):\n                return value, field_type\n        elif field_type == \"SingleLine\":\n            if isinstance(value, str):\n                return value, field_type\n            if isinstance(value, (float, int)):\n                return str(value), field_type\n            raise TypeError(\"Type must be string\")\n\n        elif field_type == \"ComboBox\":\n            if isinstance(value, dict):\n                if \"id\" in value:\n                    return value, field_type\n                if \"name\" in value:\n                    return value, field_type\n                raise TypeError(\"The dict must have either id or name key\")\n            if isinstance(value, str):\n                try:\n                    value = ObjectId(value)\n                    value = {\"id\": value}\n                except:\n                    value = {\"name\": value}\n                return value, field_type\n            raise TypeError(\"Only string and dict supported\")\n\n        elif field_type == \"MultiLine\":\n            if isinstance(value, dict):\n                if \"content\" not in value:\n                    raise TypeError(\"Key 'content' is required\")\n                return value, field_type\n            if isinstance(value, str):\n                value = {\"content\": value}\n                return value, field_type\n            raise TypeError(\"Only string and dict supported\")\n\n        elif field_type == \"CheckBox\":\n            if not isinstance(value, bool):\n                raise TypeError(\"value must be a bool\")\n            return value, field_type\n        elif field_type == \"Calculation\":\n            return None, field_type\n\n    def update_unit(self, unit: Union[Dict, str]) -&gt; str:\n        \"\"\"\n        Parameters\n        ----------\n        unit : Union[Dict, str]\n            Dictionary with id or name, or string representing the name, or string representing the id.\n\n        Returns\n        -------\n        id: str\n            The id of the updated unit.\n\n        Raises\n        ------\n        None\n\n        \"\"\"\n\n        unit = self._check_unit(unit)\n        data = {\"id\": self.id,\n                \"unit\": unit}\n        id = self._post(data)\n        self.unit = unit\n        return id\n\n    @classmethod\n    def _check_unit(cls, unit):\n        if not unit:\n            return unit\n        if isinstance(unit, dict):\n            if \"id\" in unit:\n                return unit\n            if \"name\" in unit:\n                return unit\n            raise TypeError(\"The dict must have either id or name key\")\n\n        elif isinstance(unit, str):\n            try:\n                unit = ObjectId(unit)\n                unit = {\"id\": unit}\n            except:\n                unit = {\"name\": unit}\n            return unit\n        raise TypeError(\"Only string and dict supported\")\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\", value=None, unit=None,\n               project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Parameters\n        ----------\n        field_name : str, optional\n            Name of the field. Either field name and field_type must be specified, or field_id must be specified.\n        field_type : str, optional\n            Type of the field. Must be one of the following:\n\n                - Numeric fields: numeric, numeric-field, numeric_field\n                - Date fields: date, date_field, date-field, datefield\n                - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n                - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n                - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n                - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n                - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        field_id : str, optional\n            ID of the field.\n        value : None, float, int, str, datetime, date, optional\n            Value of the field. The data type depends on the field_type parameter:\n\n                - Numeric fields: float or int, or a string convertible to a float\n                - Date fields: datetime, date object, unix timestamp, or string with iso format\n                - Text fields: string\n                - List fields: dictionary with id or name as key, or string with name, or string with id\n                - Notebook fields: dictionary with content as key, or string\n                - Checkbox fields:  boolean\n\n        unit : dict, str, optional\n            Unit of the field. Can be either a dictionary with id or name, or a string with the name.\n        project_id : str, optional\n            Optionally to create fielddata in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        dict\n            Instance of the `fielddata` class.\n\n        Raises\n        ------\n        ValueError\n            If field_id not specified, fieldname and fieldtype must be specified.\n\n        \"\"\"\n\n        from furthrmind.collection import Field\n        data = {}\n        if field_id:\n            data.update({\"fieldid\": field_id})\n            field: Field = Field.get(id=field_id)\n            field_type = field.type\n\n        value, field_type = FieldData._check_value_type(value, field_type)\n        data[\"value\"] = value\n\n        if not field_id:\n            if not field_name or not field_type:\n                raise ValueError(\"fieldname and fieldtype must be specified\")\n            data.update(\n                {\"fieldname\": field_name, \"fieldtype\": field_type})\n\n        if unit:\n            unit = FieldData._check_unit(unit)\n            data[\"unit\"] = unit\n\n        id = FieldData._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Parameters\n        ----------\n        data_list: List[Dict]\n            List with dictionaries containing the following keys:\n            - field_name: name of the field. Either field name and field_type must be specified, or field_id must be specified\n            - field_type: type of the field. Must be one of the following:\n\n                - Numeric fields: numeric, numeric-field, numeric_field\n                - Date fields: date, date_field, date-field, datefield\n                - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n                - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n                - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n                - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n                - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n            - field_id: id of the field\n            - value:\n\n                - Numeric fields: float or int, or a string convertible to a float\n                - Date fields: datetime, date object, unix timestamp, or string with iso format\n                - Text fields: string\n                - List fields: dictionary with id or name as key, or string with name, or string with id\n                - Notebook fields: dictionary with content as key, or string\n                - Checkbox fields:  boolean\n\n            - unit: dictionary with id or name, or name as string, or id as string\n\n        project_id: str, optional\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Dict]\n            List with dictionaries of instances of the fielddata class\n\n        \"\"\"\n\n        from furthrmind.collection import Field\n\n        post_data_list = []\n        for data in data_list:\n            field_id = data.get(\"field_id\")\n            field_name = data.get(\"field_name\")\n            field_type = data.get(\"field_type\")\n            value = data.get(\"value\")\n            unit = data.get(\"unit\")\n\n            _data = {}\n            if field_id:\n                _data.update({\"fieldid\": field_id})\n                field = Field(id=field_id)\n                field.get()\n                field_type = field.type\n\n            value, field_type = FieldData._check_value_type(value, field_type)\n            _data[\"value\"] = value\n\n            if not field_id:\n                if not field_name or not field_type:\n                    raise ValueError(\"field_name and field_type must be specified\")\n                _data.update(\n                    {\"fieldname\": field_name,\n                     \"fieldtype\": field_type})\n\n            if unit:\n                unit = FieldData._check_unit(unit)\n                _data[\"unit\"] = unit\n            post_data_list.append(_data)\n\n        id_list = FieldData._post(post_data_list, project_id, force_list=True)\n        for data, id in zip(data_list, id_list):\n            data[\"id\"] = id\n        return data_list\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.create","title":"<code>create(field_name='', field_type='', field_id='', value=None, unit=None, project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field. Either field name and field_type must be specified, or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of the field. Must be one of the following:</p> <pre><code>- Numeric fields: numeric, numeric-field, numeric_field\n- Date fields: date, date_field, date-field, datefield\n- Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n- List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n- Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n- Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n- Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n</code></pre> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field.</p> <code>''</code> <code>value</code> <code>(None, float, int, str, datetime, date)</code> <p>Value of the field. The data type depends on the field_type parameter:</p> <pre><code>- Numeric fields: float or int, or a string convertible to a float\n- Date fields: datetime, date object, unix timestamp, or string with iso format\n- Text fields: string\n- List fields: dictionary with id or name as key, or string with name, or string with id\n- Notebook fields: dictionary with content as key, or string\n- Checkbox fields:  boolean\n</code></pre> <code>None</code> <code>unit</code> <code>(dict, str)</code> <p>Unit of the field. Can be either a dictionary with id or name, or a string with the name.</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Optionally to create fielddata in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>Instance of the <code>fielddata</code> class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If field_id not specified, fieldname and fieldtype must be specified.</p> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\", value=None, unit=None,\n           project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field. Either field name and field_type must be specified, or field_id must be specified.\n    field_type : str, optional\n        Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n    field_id : str, optional\n        ID of the field.\n    value : None, float, int, str, datetime, date, optional\n        Value of the field. The data type depends on the field_type parameter:\n\n            - Numeric fields: float or int, or a string convertible to a float\n            - Date fields: datetime, date object, unix timestamp, or string with iso format\n            - Text fields: string\n            - List fields: dictionary with id or name as key, or string with name, or string with id\n            - Notebook fields: dictionary with content as key, or string\n            - Checkbox fields:  boolean\n\n    unit : dict, str, optional\n        Unit of the field. Can be either a dictionary with id or name, or a string with the name.\n    project_id : str, optional\n        Optionally to create fielddata in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    dict\n        Instance of the `fielddata` class.\n\n    Raises\n    ------\n    ValueError\n        If field_id not specified, fieldname and fieldtype must be specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Field\n    data = {}\n    if field_id:\n        data.update({\"fieldid\": field_id})\n        field: Field = Field.get(id=field_id)\n        field_type = field.type\n\n    value, field_type = FieldData._check_value_type(value, field_type)\n    data[\"value\"] = value\n\n    if not field_id:\n        if not field_name or not field_type:\n            raise ValueError(\"fieldname and fieldtype must be specified\")\n        data.update(\n            {\"fieldname\": field_name, \"fieldtype\": field_type})\n\n    if unit:\n        unit = FieldData._check_unit(unit)\n        data[\"unit\"] = unit\n\n    id = FieldData._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List with dictionaries containing the following keys: - field_name: name of the field. Either field name and field_type must be specified, or field_id must be specified - field_type: type of the field. Must be one of the following:</p> <pre><code>- Numeric fields: numeric, numeric-field, numeric_field\n- Date fields: date, date_field, date-field, datefield\n- Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n- List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n- Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n- Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n- Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n</code></pre> <ul> <li>field_id: id of the field</li> <li> <p>value:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields:  boolean</li> </ul> </li> <li> <p>unit: dictionary with id or name, or name as string, or id as string</p> </li> </ul> required <code>project_id</code> <code>str</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List with dictionaries of instances of the fielddata class</p> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List with dictionaries containing the following keys:\n        - field_name: name of the field. Either field name and field_type must be specified, or field_id must be specified\n        - field_type: type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: id of the field\n        - value:\n\n            - Numeric fields: float or int, or a string convertible to a float\n            - Date fields: datetime, date object, unix timestamp, or string with iso format\n            - Text fields: string\n            - List fields: dictionary with id or name as key, or string with name, or string with id\n            - Notebook fields: dictionary with content as key, or string\n            - Checkbox fields:  boolean\n\n        - unit: dictionary with id or name, or name as string, or id as string\n\n    project_id: str, optional\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Dict]\n        List with dictionaries of instances of the fielddata class\n\n    \"\"\"\n\n    from furthrmind.collection import Field\n\n    post_data_list = []\n    for data in data_list:\n        field_id = data.get(\"field_id\")\n        field_name = data.get(\"field_name\")\n        field_type = data.get(\"field_type\")\n        value = data.get(\"value\")\n        unit = data.get(\"unit\")\n\n        _data = {}\n        if field_id:\n            _data.update({\"fieldid\": field_id})\n            field = Field(id=field_id)\n            field.get()\n            field_type = field.type\n\n        value, field_type = FieldData._check_value_type(value, field_type)\n        _data[\"value\"] = value\n\n        if not field_id:\n            if not field_name or not field_type:\n                raise ValueError(\"field_name and field_type must be specified\")\n            _data.update(\n                {\"fieldname\": field_name,\n                 \"fieldtype\": field_type})\n\n        if unit:\n            unit = FieldData._check_unit(unit)\n            _data[\"unit\"] = unit\n        post_data_list.append(_data)\n\n    id_list = FieldData._post(post_data_list, project_id, force_list=True)\n    for data, id in zip(data_list, id_list):\n        data[\"id\"] = id\n    return data_list\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.set_calculation_result","title":"<code>set_calculation_result(value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>Dict</code> <p>A dictionary representing the calculation result.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the field type is not a calculation</p> <p>Returns:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the calculation field.</p> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>def set_calculation_result(self, value: Dict) -&gt; str:\n    \"\"\"\n    Parameters\n    ----------\n    value: dict\n        A dictionary representing the calculation result.\n\n    Raises\n    ------\n    TypeError\n        If the field type is not a calculation\n\n    Returns\n    -------\n    id: str\n        The ID of the calculation field.\n    \"\"\"\n\n    if not self.field_type.lower() in [\"calculation\", \"rawdatacalc\"]:\n        raise TypeError(\"Only applicable for calculation field\")\n\n    url = f\"{self.fm.base_url}/set-result/{self.id}\"\n    response = self.fm.session.post(url, json=value)\n    if response.status_code != 200:\n        raise ValueError(\"Setting calculation result failed\")\n    return self.id\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.update_unit","title":"<code>update_unit(unit)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <p>Returns:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the updated unit.</p> <p>Raises:</p> Type Description <code>None</code> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>def update_unit(self, unit: Union[Dict, str]) -&gt; str:\n    \"\"\"\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    id: str\n        The id of the updated unit.\n\n    Raises\n    ------\n    None\n\n    \"\"\"\n\n    unit = self._check_unit(unit)\n    data = {\"id\": self.id,\n            \"unit\": unit}\n    id = self._post(data)\n    self.unit = unit\n    return id\n</code></pre>"},{"location":"fielddata/#furthrmind.collection.fielddata.FieldData.update_value","title":"<code>update_value(value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <p>The value to update the fielddata. The valid types for each field type are as follows:</p> <ul> <li>numeric, numeric-field, numeric_field: float or int, or a string convertable to a float</li> <li>date, date_field, date-field, datefield: datetime, or date object, or unix timestamp or string with     iso format</li> <li>singleline, singlelinefield, text, text-field, text_field, textfield: string</li> <li>combobox, comboboxfield, list, list-field, list_field, listfield: dict with id or name as key, or string     with name, or string with id</li> <li>multiline, notebook, notebookfield, notebook-field, notebook_field: dict with content as key, or string</li> <li>checkbox, checkbox-field, checkbox_field, checkboxfield: boolean</li> </ul> required <p>Returns:</p> Name Type Description <code>id</code> <code>str</code> <p>The id of the updated fielddata.</p> Source code in <code>furthrmind/collection/fielddata.py</code> <pre><code>def update_value(self, value) -&gt; str:\n    \"\"\"\n    Parameters\n    ----------\n    value :\n        The value to update the fielddata. The valid types for each field type are as follows:\n\n        - numeric, numeric-field, numeric_field: float or int, or a string convertable to a float\n        - date, date_field, date-field, datefield: datetime, or date object, or unix timestamp or string with\n            iso format\n        - singleline, singlelinefield, text, text-field, text_field, textfield: string\n        - combobox, comboboxfield, list, list-field, list_field, listfield: dict with id or name as key, or string\n            with name, or string with id\n        - multiline, notebook, notebookfield, notebook-field, notebook_field: dict with content as key, or string\n        - checkbox, checkbox-field, checkbox_field, checkboxfield: boolean\n\n    Returns\n    -------\n    id : str\n        The id of the updated fielddata.\n    \"\"\"\n\n    value, field_type = self.__class__._check_value_type(value, self.field_type)\n    data = {\"id\": self.id,\n            \"value\": value}\n    id = self._post(data)\n    self.value = value\n    return id\n</code></pre>"},{"location":"file/","title":"File","text":""},{"location":"file/#furthrmind.collection.file.File","title":"<code>File</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the file</p> <code>name</code> <code>str</code> <p>name of the file including the extension</p> Source code in <code>furthrmind/collection/file.py</code> <pre><code>class File(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the file\n    name : str\n        name of the file including the extension\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n\n    _attr_definition = {\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    @classmethod\n    def get(cls, id=None):\n        raise TypeError(\"Not implemented\")\n\n    @classmethod\n    def _get_all(cls):\n        raise TypeError(\"Not implemented\")\n\n    def download(self, folder: str, overwrite: bool = False):\n        \"\"\"\n        Method to download a file\n\n        Parameters\n        ----------\n        folder : str\n            The folder where the file should be saved\n        overwrite : bool, optional\n            Whether to overwrite the existing file in the folder if it already exists (default is False)\n        \"\"\"\n\n        from furthrmind.file_loader import FileLoader\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n\n        if not os.path.isdir(folder):\n            raise ValueError(\"Folder does not exist\")\n        fl.downloadFile(self.id, folder, overwrite)\n\n    def download_bytes(self) -&gt; BytesIO:\n        \"\"\"\n        Method to download a file and save to BytesIO object\n\n        Returns:\n            BytesIO: The downloaded file stored as BytesIO object\n        \"\"\"\n\n        from furthrmind.file_loader import FileLoader\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n\n        flag, bytes_io = fl.downloadFile(self.id, bytesIO=True)\n        return bytes_io\n\n    def update_file(self, file_path: str, file_name: str = \"\"):\n        \"\"\"\n        Update a file.\n\n        Parameters\n        ----------\n        file_path : str\n            The path to the file.\n        file_name : str, optional\n            The new file name. Defaults to \"\". If not set, the file_name is taken from the file_path.\n\n        Raises\n        ------\n        ValueError\n            If the file does not exist.\n\n        \"\"\"\n        from furthrmind.file_loader import FileLoader\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n\n        if not os.path.isfile(file_path):\n            raise ValueError(\"File does not exist\")\n\n        fl.updateFile(self.id, file_path, file_name)\n</code></pre>"},{"location":"file/#furthrmind.collection.file.File.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"file/#furthrmind.collection.file.File.download","title":"<code>download(folder, overwrite=False)</code>","text":"<p>Method to download a file</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder where the file should be saved</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the existing file in the folder if it already exists (default is False)</p> <code>False</code> Source code in <code>furthrmind/collection/file.py</code> <pre><code>def download(self, folder: str, overwrite: bool = False):\n    \"\"\"\n    Method to download a file\n\n    Parameters\n    ----------\n    folder : str\n        The folder where the file should be saved\n    overwrite : bool, optional\n        Whether to overwrite the existing file in the folder if it already exists (default is False)\n    \"\"\"\n\n    from furthrmind.file_loader import FileLoader\n    fl = FileLoader(self.fm.host, self.fm.api_key)\n\n    if not os.path.isdir(folder):\n        raise ValueError(\"Folder does not exist\")\n    fl.downloadFile(self.id, folder, overwrite)\n</code></pre>"},{"location":"file/#furthrmind.collection.file.File.download_bytes","title":"<code>download_bytes()</code>","text":"<p>Method to download a file and save to BytesIO object</p> <p>Returns:     BytesIO: The downloaded file stored as BytesIO object</p> Source code in <code>furthrmind/collection/file.py</code> <pre><code>def download_bytes(self) -&gt; BytesIO:\n    \"\"\"\n    Method to download a file and save to BytesIO object\n\n    Returns:\n        BytesIO: The downloaded file stored as BytesIO object\n    \"\"\"\n\n    from furthrmind.file_loader import FileLoader\n    fl = FileLoader(self.fm.host, self.fm.api_key)\n\n    flag, bytes_io = fl.downloadFile(self.id, bytesIO=True)\n    return bytes_io\n</code></pre>"},{"location":"file/#furthrmind.collection.file.File.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"file/#furthrmind.collection.file.File.update_file","title":"<code>update_file(file_path, file_name='')</code>","text":"<p>Update a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>file_name</code> <code>str</code> <p>The new file name. Defaults to \"\". If not set, the file_name is taken from the file_path.</p> <code>''</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file does not exist.</p> Source code in <code>furthrmind/collection/file.py</code> <pre><code>def update_file(self, file_path: str, file_name: str = \"\"):\n    \"\"\"\n    Update a file.\n\n    Parameters\n    ----------\n    file_path : str\n        The path to the file.\n    file_name : str, optional\n        The new file name. Defaults to \"\". If not set, the file_name is taken from the file_path.\n\n    Raises\n    ------\n    ValueError\n        If the file does not exist.\n\n    \"\"\"\n    from furthrmind.file_loader import FileLoader\n    fl = FileLoader(self.fm.host, self.fm.api_key)\n\n    if not os.path.isfile(file_path):\n        raise ValueError(\"File does not exist\")\n\n    fl.updateFile(self.id, file_path, file_name)\n</code></pre>"},{"location":"group/","title":"Group","text":""},{"location":"group/#furthrmind.collection.group.Group","title":"<code>Group</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the group</p> <code>name</code> <code>str</code> <p>name of the group</p> <code>shortid</code> <code>str</code> <p>shortid of the group</p> <code>files</code> <code>List[File]</code> <p>List of files belonging to this group. See File for more information.</p> <code>fielddata</code> <code>List[FieldData]</code> <p>List of field data belonging to this group. See FieldData for more information.</p> <code>samples</code> <code>List[Sample]</code> <p>This list contains 'sample' objects belonging to this group. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'sample' objects, see the provided Sample.</p> <code>experiments</code> <code>List[Experiment]</code> <p>This list contains 'experiment' objects belonging to this group. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'experiment' objects, see the provided Experiment.</p> <code>researchitems</code> <code>Dict[str, List[ResearchItem]]</code> <p>This is a dictionary with category name as keys and lists with the corresponding <code>researchitem</code> objects belonging  to this group as values. The <code>researchitem</code> objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'researchitem' objects, see the provided ResearchItem.</p> <code>sub_groups</code> <code>List[Group]</code> <p>This list contains 'group' objects that are subgroups of this group. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>parent_group</code> <code>Group</code> <p>If the group is a subgroup, the attribute holds its parent group. This object is partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/group.py</code> <pre><code>class Group(BaseClassWithFieldData):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the group\n    name : str\n        name of the group\n    shortid : str\n        shortid of the group\n    files : List[File]\n        List of files belonging to this group. See [File](file.md) for more information.\n    fielddata : List[FieldData]\n        List of field data belonging to this group. See [FieldData](fielddata.md) for more information.\n    samples : List[Sample]\n        This list contains 'sample' objects belonging to this group. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'sample' objects, see the provided [Sample](sample.md).\n    experiments : List[Experiment]\n        This list contains 'experiment' objects belonging to this group. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'experiment' objects, see the provided [Experiment](experiment.md).\n    researchitems : Dict[str, List[ResearchItem]]\n        This is a dictionary with category name as keys and lists with the corresponding `researchitem` objects belonging\n         to this group as values. The `researchitem` objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'researchitem' objects, see the provided [ResearchItem](researchitem.md).\n    sub_groups : List[Group]\n        This list contains 'group' objects that are subgroups of this group. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    parent_group : Group\n        If the group is a subgroup, the attribute holds its parent group. This object is partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    neglect = False\n    shortid = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n    experiments: List[\"Experiment\"] = []\n    samples: List[\"Sample\"] = []\n    researchitems: Dict[str, List[\"ResearchItem\"]] = {}\n    sub_groups: List[Self] = []\n    parent_group: Self = None\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"},\n        \"samples\": {\"class\": \"Sample\"},\n        \"experiments\": {\"class\": \"Experiment\"},\n        \"researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"sub_groups\": {\"class\": \"Group\"},\n        \"parent_group\": {\"class\": \"Group\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Group.fm.get_project_url(project_id)\n        url = f\"{project_url}/groups/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/groups/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/groups\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/groups\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", name: str = \"\", shortid: str = \"\", parent_group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get one group by its id, name, or shortid.\n        If called on an instance of the class, the id of the class is used.\n\n        Parameters\n        ----------\n        id : str\n            id or short_id of requested group\n        name : str\n            name of requested group. For subgroups, see parent_group_id parameter\n        shortid : str\n            shortid of requested group\n        parent_group_id : str\n            id of parent group.\n            If a subgroup is requested, the name and the parent_group_id is required\n        project_id : str, optional\n            Optionally to get a group from another project as the furthrmind sdk was initiated with.\n            Defaults to None\n\n        Returns\n        -------\n        Self\n            Instance of group class\n\n        Raises\n        ------\n        AssertionError\n            When used as a class method, id, name, or shortid must be specified.\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name or shortid, \"Either id or name must be specified\"\n\n        return cls._get(id, shortid, name, parent_group_id=parent_group_id, project_id=project_id)\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n                 project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get many groups\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of ids to filter the groups.\n        shortids : List[str]\n            List of short_ids to filter the groups.\n        names : List[str]\n            List of names to filter the groups.\n        project_id : str, optional\n            Optionally to get groups from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the Group class.\n\n        Raises\n        ------\n        AssertionError\n            If none of the parameters (ids, shortids, or names) are specified.\n\n        \"\"\"\n\n        assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n        return cls._get_many(ids, shortids, names, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all groups belonging to one project\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get groups from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instances of the group class.\n\n        \"\"\"\n\n        return super()._get_all(project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, parent_group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to create a new group.\n\n        Parameters\n        ----------\n        name: str\n            The name of the item to be created.\n        parent_group_id: str, optional\n            The ID of the parent group where the new group should belong to. Defaults to an empty string.\n        project_id: str, optional\n            Optionally, create a group in another project as the furthrmind SDK was initiated with\n\n        Returns\n        -------\n        instance of the group class\n        \"\"\"\n\n        data = {\"name\": name}\n        if parent_group_id:\n            data[\"parent_group\"] = {\"id\": parent_group_id}\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, name_list: List[str], project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to create multiple groups\n\n        Parameters\n        ----------\n        name_list: List[str]\n            A list containing names of the groups to be created.\n        project_id: str, optional\n            Optionally to create groups in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the group class corresponding to the groups created.\n\n        \"\"\"\n\n        data_list = [{\"name\": name} for name in name_list]\n\n        id_list = cls._post(data_list, project_id, force_list=True)\n\n        for data, id in zip(data_list, id_list):\n            data[\"id\"] = id\n\n        return data_list\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.create","title":"<code>create(name, parent_group_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create a new group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to be created.</p> required <code>parent_group_id</code> <code>str</code> <p>The ID of the parent group where the new group should belong to. Defaults to an empty string.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally, create a group in another project as the furthrmind SDK was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>instance of the group class</code> Source code in <code>furthrmind/collection/group.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, parent_group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to create a new group.\n\n    Parameters\n    ----------\n    name: str\n        The name of the item to be created.\n    parent_group_id: str, optional\n        The ID of the parent group where the new group should belong to. Defaults to an empty string.\n    project_id: str, optional\n        Optionally, create a group in another project as the furthrmind SDK was initiated with\n\n    Returns\n    -------\n    instance of the group class\n    \"\"\"\n\n    data = {\"name\": name}\n    if parent_group_id:\n        data[\"parent_group\"] = {\"id\": parent_group_id}\n    id = cls._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.create_many","title":"<code>create_many(name_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Method to create multiple groups</p> <p>Parameters:</p> Name Type Description Default <code>name_list</code> <code>List[str]</code> <p>A list containing names of the groups to be created.</p> required <code>project_id</code> <code>str</code> <p>Optionally to create groups in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list containing instances of the group class corresponding to the groups created.</p> Source code in <code>furthrmind/collection/group.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, name_list: List[str], project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to create multiple groups\n\n    Parameters\n    ----------\n    name_list: List[str]\n        A list containing names of the groups to be created.\n    project_id: str, optional\n        Optionally to create groups in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list containing instances of the group class corresponding to the groups created.\n\n    \"\"\"\n\n    data_list = [{\"name\": name} for name in name_list]\n\n    id_list = cls._post(data_list, project_id, force_list=True)\n\n    for data, id in zip(data_list, id_list):\n        data[\"id\"] = id\n\n    return data_list\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.get","title":"<code>get(id='', name='', shortid='', parent_group_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one group by its id, name, or shortid. If called on an instance of the class, the id of the class is used.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id or short_id of requested group</p> <code>''</code> <code>name</code> <code>str</code> <p>name of requested group. For subgroups, see parent_group_id parameter</p> <code>''</code> <code>shortid</code> <code>str</code> <p>shortid of requested group</p> <code>''</code> <code>parent_group_id</code> <code>str</code> <p>id of parent group. If a subgroup is requested, the name and the parent_group_id is required</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get a group from another project as the furthrmind sdk was initiated with. Defaults to None</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of group class</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>When used as a class method, id, name, or shortid must be specified.</p> Source code in <code>furthrmind/collection/group.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", name: str = \"\", shortid: str = \"\", parent_group_id: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get one group by its id, name, or shortid.\n    If called on an instance of the class, the id of the class is used.\n\n    Parameters\n    ----------\n    id : str\n        id or short_id of requested group\n    name : str\n        name of requested group. For subgroups, see parent_group_id parameter\n    shortid : str\n        shortid of requested group\n    parent_group_id : str\n        id of parent group.\n        If a subgroup is requested, the name and the parent_group_id is required\n    project_id : str, optional\n        Optionally to get a group from another project as the furthrmind sdk was initiated with.\n        Defaults to None\n\n    Returns\n    -------\n    Self\n        Instance of group class\n\n    Raises\n    ------\n    AssertionError\n        When used as a class method, id, name, or shortid must be specified.\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name or shortid, \"Either id or name must be specified\"\n\n    return cls._get(id, shortid, name, parent_group_id=parent_group_id, project_id=project_id)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all groups belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get groups from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instances of the group class.</p> Source code in <code>furthrmind/collection/group.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all groups belonging to one project\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get groups from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instances of the group class.\n\n    \"\"\"\n\n    return super()._get_all(project_id)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.get_many","title":"<code>get_many(ids=(), shortids=(), names=(), project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get many groups</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of ids to filter the groups.</p> <code>()</code> <code>shortids</code> <code>List[str]</code> <p>List of short_ids to filter the groups.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of names to filter the groups.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get groups from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the Group class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If none of the parameters (ids, shortids, or names) are specified.</p> Source code in <code>furthrmind/collection/group.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n             project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get many groups\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of ids to filter the groups.\n    shortids : List[str]\n        List of short_ids to filter the groups.\n    names : List[str]\n        List of names to filter the groups.\n    project_id : str, optional\n        Optionally to get groups from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the Group class.\n\n    Raises\n    ------\n    AssertionError\n        If none of the parameters (ids, shortids, or names) are specified.\n\n    \"\"\"\n\n    assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n    return cls._get_many(ids, shortids, names, project_id=project_id)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"group/#furthrmind.collection.group.Group.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"project/","title":"Project","text":""},{"location":"project/#furthrmind.collection.project.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the project</p> <code>name</code> <code>str</code> <p>name of the project</p> <code>shortid</code> <code>str</code> <p>shortid of the project</p> <code>info</code> <code>str</code> <p>Detailed information about the project</p> <code>samples</code> <code>List[Sample]</code> <p>This list contains 'sample' objects belonging to this project. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'sample' objects, see the provided Sample.</p> <code>experiments</code> <code>List[Experiment]</code> <p>This list contains 'experiment' objects belonging to this project. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'experiment' objects, see the provided Experiment.</p> <code>researchitems</code> <code>Dict[str, List[ResearchItem]]</code> <p>This is a dictionary with category name as keys and lists with the corresponding <code>researchitem</code> objects belonging to this project as values. The <code>researchitem</code> objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'researchitem' objects, see the provided ResearchItem.</p> <code>groups</code> <code>List[Group]</code> <p>This list contains 'group' objects that belong to this project. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>units</code> <code>List[Unit]</code> <p>This list contains all unit objects that belong to this project. For more information about the unit object, please refer to Unit.</p> <code>fields</code> <code>List[Field]</code> <p>This list contains all fields that belong to this project. Each entry is a Field object.</p> <code>permissions</code> <code>Dict</code> <p>This is a dictionary containing various keys. The <code>owner</code> key represents the owner of the project. The <code>users</code> key refers to a list of users granted access to this project, including their respective access levels. Lastly, the <code>usergroups</code> key relates to a list of usergroups with access privileges to this project, also presenting their respective access levels.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/project.py</code> <pre><code>class Project(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the project\n    name : str\n        name of the project\n    shortid : str\n        shortid of the project\n    info : str\n        Detailed information about the project\n    samples : List[Sample]\n        This list contains 'sample' objects belonging to this project. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'sample' objects, see the provided [Sample](sample.md).\n    experiments : List[Experiment]\n        This list contains 'experiment' objects belonging to this project. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'experiment' objects, see the provided [Experiment](experiment.md).\n    researchitems : Dict[str, List[ResearchItem]]\n        This is a dictionary with category name as keys and lists with the corresponding `researchitem` objects belonging\n        to this project as values. The `researchitem` objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'researchitem' objects, see the provided [ResearchItem](researchitem.md).\n    groups : List[Group]\n        This list contains 'group' objects that belong to this project. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    units : List[Unit]\n        This list contains all unit objects that belong to this project. For more information about the unit object, please\n        refer to [Unit](unit.md).\n    fields : List[Field]\n        This list contains all fields that belong to this project. Each entry is a [Field](field.md) object.\n    permissions : Dict\n        This is a dictionary containing various keys. The `owner` key represents the owner of the project.\n        The `users` key refers to a list of users granted access to this project, including their respective access levels.\n        Lastly, the `usergroups` key relates to a list of usergroups with access privileges to this project, also presenting\n        their respective access levels.\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    info = \"\"\n    shortid = \"\"\n    samples: List[\"Sample\"] = []\n    experiments: List[\"Experiment\"] = []\n    groups: List[\"Group\"] = []\n    units: List[\"Unit\"] = []\n    researchitems: Dict[str, List[\"ResearchItem\"]] = {}\n    permissions: Dict[str, List] = {}\n    fields: List[\"Field\"] = []\n\n    _attr_definition = {\n        \"samples\": {\"class\": \"Sample\"},\n        \"experiments\": {\"class\": \"Experiment\"},\n        \"groups\": {\"class\": \"Group\"},\n        \"units\": {\"class\": \"Unit\"},\n        \"researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"fields\": {\"class\": \"Field\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self):\n        project_url = self.fm.get_project_url(self.id)\n        return project_url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(id)\n        return project_url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        return f\"{cls.fm.base_url}/projects\"\n\n    @classmethod\n    def _post_url(cls):\n        return f\"{cls.fm.base_url}/projects\"\n\n    @classmethod\n    def get(cls, id: str = \"\", name: str = \"\") -&gt; Self:\n        \"\"\"\n        This method is used to get one project by its id or name.\n        If called on an instance of the class, the id of the class is used.\n        Either id or name must be specified.\n\n        Parameters\n        ----------\n        id : str, optional\n            id or short_id of the requested project.\n            Default value is an empty string.\n        name : str, optional\n            name of the requested project.\n            Default value is an empty string.\n\n        Returns\n        -------\n        Self\n            Instance of the project class.\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name, \"Either id or name must be specified\"\n\n        return cls._get(id=id, name=name)\n\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), names: List[str] = ()) -&gt; List[Self]:\n        \"\"\"\n        Method to get many projects\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of ids.\n\n        names : List[str]\n            List of names.\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the class.\n\n        Raises\n        ------\n        AssertionError\n            If neither ids nor names are specified.\n        \"\"\"\n        pass\n\n        assert ids or names, \"Either ids or names must be specified\"\n        return cls._get_many(ids, names)\n\n    @classmethod\n    def get_all(cls) -&gt; List[Self]:\n        \"\"\"\n        Method to get all projects\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the class.\n\n        \"\"\"\n\n        return super()._get_all()\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str) -&gt; Self:\n        \"\"\"\n        Method to create a new project\n\n        Parameters\n        ----------\n        name : str\n            Name of the new project\n\n        Returns\n        -------\n        Self\n            Instance of the project class\n\n        Raises\n        ------\n        ValueError\n            If name is empty or None\n\n        \"\"\"\n\n        if not name:\n            raise ValueError(\"Name is required\")\n        data = {\"name\": name}\n        id = cls._post(data)\n        data[\"id\"] = id\n        return data\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.create","title":"<code>create(name)</code>  <code>classmethod</code>","text":"<p>Method to create a new project</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the new project</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the project class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If name is empty or None</p> Source code in <code>furthrmind/collection/project.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str) -&gt; Self:\n    \"\"\"\n    Method to create a new project\n\n    Parameters\n    ----------\n    name : str\n        Name of the new project\n\n    Returns\n    -------\n    Self\n        Instance of the project class\n\n    Raises\n    ------\n    ValueError\n        If name is empty or None\n\n    \"\"\"\n\n    if not name:\n        raise ValueError(\"Name is required\")\n    data = {\"name\": name}\n    id = cls._post(data)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.get","title":"<code>get(id='', name='')</code>  <code>classmethod</code>","text":"<p>This method is used to get one project by its id or name. If called on an instance of the class, the id of the class is used. Either id or name must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id or short_id of the requested project. Default value is an empty string.</p> <code>''</code> <code>name</code> <code>str</code> <p>name of the requested project. Default value is an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the project class.</p> Source code in <code>furthrmind/collection/project.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", name: str = \"\") -&gt; Self:\n    \"\"\"\n    This method is used to get one project by its id or name.\n    If called on an instance of the class, the id of the class is used.\n    Either id or name must be specified.\n\n    Parameters\n    ----------\n    id : str, optional\n        id or short_id of the requested project.\n        Default value is an empty string.\n    name : str, optional\n        name of the requested project.\n        Default value is an empty string.\n\n    Returns\n    -------\n    Self\n        Instance of the project class.\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name, \"Either id or name must be specified\"\n\n    return cls._get(id=id, name=name)\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.get_all","title":"<code>get_all()</code>  <code>classmethod</code>","text":"<p>Method to get all projects</p> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the class.</p> Source code in <code>furthrmind/collection/project.py</code> <pre><code>@classmethod\ndef get_all(cls) -&gt; List[Self]:\n    \"\"\"\n    Method to get all projects\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the class.\n\n    \"\"\"\n\n    return super()._get_all()\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.get_many","title":"<code>get_many(ids=(), names=())</code>  <code>classmethod</code>","text":"<p>Method to get many projects</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of ids.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of names.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither ids nor names are specified.</p> Source code in <code>furthrmind/collection/project.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), names: List[str] = ()) -&gt; List[Self]:\n    \"\"\"\n    Method to get many projects\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of ids.\n\n    names : List[str]\n        List of names.\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the class.\n\n    Raises\n    ------\n    AssertionError\n        If neither ids nor names are specified.\n    \"\"\"\n    pass\n\n    assert ids or names, \"Either ids or names must be specified\"\n    return cls._get_many(ids, names)\n</code></pre>"},{"location":"project/#furthrmind.collection.project.Project.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"researchitem/","title":"ResearchItem","text":""},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem","title":"<code>ResearchItem</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code>, <code>BaseClassWithFiles</code>, <code>BaseClassWithGroup</code>, <code>BaseClassWithLinking</code>, <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the researchitem</p> <code>name</code> <code>str</code> <p>name of the researchitem</p> <code>shortid</code> <code>str</code> <p>shortid of the researchitem</p> <code>files</code> <code>List[File]</code> <p>List of files belonging to this researchitem. See File for more information.</p> <code>fielddata</code> <code>List[FieldData]</code> <p>List of field data belonging to this researchitem. See FieldData for more information.</p> <code>linked_samples</code> <code>List[Sample]</code> <p>This list contains 'sample' objects linked to the current researchitem. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'sample' objects, see the provided Sample.</p> <code>linked_experiments</code> <code>List[Experiment]</code> <p>This list contains 'experiment' objects linked to the current researchitem. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'experiment' objects, see the provided Experiment.</p> <code>linked_researchitems</code> <code>Dict[str, List[ResearchItem]]</code> <p>This is a dictionary with category name as keys and lists with the corresponding <code>researchitem</code> objects as values. The <code>researchitem</code> objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'researchitem' objects, see the provided ResearchItem.</p> <code>groups</code> <code>List[Group]</code> <p>This list contains 'group' objects the researchitem belongs to. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>category</code> <code>Category</code> <p>Category object of the researchitem.</p> <code>datatables</code> <code>List[DataTable]</code> <p>This list contains 'datatable' objects that belong to this researchitem. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'datatable' objects, see the provided DataTable.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>class ResearchItem(BaseClassWithFieldData, BaseClassWithFiles, BaseClassWithGroup, BaseClassWithLinking, BaseClass ):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the researchitem\n    name : str\n        name of the researchitem\n    shortid : str\n        shortid of the researchitem\n    files : List[File]\n        List of files belonging to this researchitem. See [File](file.md) for more information.\n    fielddata : List[FieldData]\n        List of field data belonging to this researchitem. See [FieldData](fielddata.md) for more information.\n    linked_samples : List[Sample]\n        This list contains 'sample' objects linked to the current researchitem. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'sample' objects, see the provided [Sample](sample.md).\n    linked_experiments : List[Experiment]\n        This list contains 'experiment' objects linked to the current researchitem. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'experiment' objects, see the provided [Experiment](experiment.md).\n    linked_researchitems : Dict[str, List[ResearchItem]]\n        This is a dictionary with category name as keys and lists with the corresponding `researchitem` objects as values.\n        The `researchitem` objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'researchitem' objects, see the provided [ResearchItem](researchitem.md).\n    groups : List[Group]\n        This list contains 'group' objects the researchitem belongs to. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    category : Category\n        [Category](category.md) object of the researchitem.\n    datatables : List[DataTable]\n        This list contains 'datatable' objects that belong to this researchitem. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'datatable' objects, see the provided [DataTable](datatable.md).\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    neglect = False\n    shortid = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n    linked_experiments: List[\"Experiment\"] = []\n    linked_samples: List[\"Sample\"] = []\n    linked_researchitems: Dict[str, List[\"ResearchItem\"]] = {}\n    groups: List[\"Group\"] = []\n    category: \"Category\" = None\n    datatables: List[\"DataTable\"] = []\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"},\n        \"groups\": {\"class\": \"Group\"},\n        \"linked_samples\": {\"class\": \"Sample\"},\n        \"linked_experiments\": {\"class\": \"Experiment\"},\n        \"linked_researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"datatables\": {\"class\": \"DataTable\"},\n        \"category\": {\"class\": \"Category\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = ResearchItem.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchitems/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchitems/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchitems\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/researchitems\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", shortid: str = \"\", name: str = \"\", category_name: str = \"\", category_id: str = \"\",\n            project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get  one researchitem by its id, short_id or name. If requested by name, also category_name or\n        category_id is required.\n        If called on an instance of the class, the id of the class is used\n\n        Parameters\n        ----------\n        id : str, optional\n            The id of the requested research item.\n\n        shortid : str, optional\n            The short id of the requested research item.\n\n        name : str, optional\n            The name of the requested research item.\n\n        category_name : str, optional\n            The name of the category the research item belongs to.\n\n        category_id : str, optional\n            The id of the category the research item belongs to.\n\n        project_id : str, optional\n            Optionally to get a researchitem from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            Instance of the researchitem class.\n\n        Raises\n        ------\n        AssertionError\n            If used as a class method and neither id, shortid, nor name is provided.\n            If used as a class method and name is provided but neither category_name nor category_id is provided.\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id or shortid or name, AssertionError(\"Either id, shortid or name must be given\")\n            if not id and name:\n                assert category_name or category_id, AssertionError(\"Either category name or id must be given\")\n\n        return cls._get(id=id, shortid=shortid, name=name,\n                        category_name=category_name, category_id=category_id, project_id=project_id)\n\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n                 category_name=None, category_id=None, project_id=None) -&gt; List[Self]:\n        \"\"\"\n        Method to get many researchitems by ids or shortids. If requested by names, also category_name or category_id\n        is required. If requested by name items from one category can be requested at a time.\n\n        Parameters\n        ----------\n        ids : List[str]\n             List of experiment ids.\n        shortids : List[str]\n             List of experiment short ids.\n        names : List[str]\n             List of experiment names.\n        category_name : str, optional\n             Name of the category the research item belongs to.\n        category_id : str, optional\n             Id of the category the research item belongs to.\n        project_id : str, optional\n             Optionally to get researchitems from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n             List of instances of the researchitem class.\n\n        Raises\n        ------\n        AssertionError\n            ids, shortids, nor names must be provided.\n            If names is provided but neither category_name nor category_id is provided.\n\n        \"\"\"\n\n        assert ids or shortids or names, AssertionError(\"Either ids, shortids or names must be given\")\n        if names:\n            assert category_name or category_id, AssertionError(\"Either category_name or category_id must be given\")\n\n        return cls._get_many(ids, shortids, names, category_name, category_id, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all researchitems belonging to one project\n\n        Parameters\n        ----------\n        project_id: str\n            Optionally to get researchitems from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the researchitem class.\n        \"\"\"\n\n        return cls._get_all(project_id)\n\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, group_name: str = \"\", group_id: str = \"\", category_name: str = \"\", category_id: str = \"\",\n               project_id=None) -&gt; Self:\n        \"\"\"\n        Parameters\n        ----------\n        name : str\n            The name of the item to be created.\n        group_name : str, optional\n            The name of the group where the new item will belong to. Group name can only be considered for groups that\n            are not subgroups. Either `group_name` or `group_id` must be specified.\n        group_id : str, optional\n            The id of the group where the new item will belong to. Either `group_name` or `group_id` must be specified.\n        category_name : str, optional\n            The name of the category that the new item will belong to. Either `category_name` or `category_id` must be specified.\n        category_id : str, optional\n            The id of the category that the new item will belong to. Either `category_name` or `category_id` must be specified.\n        project_id : object, optional\n            Optionally create a researchitem in another project as the furthrmind sdk was initiated with.\n\n        Returns\n        -------\n        Self\n            instance of the researchitem class\n\n        Raises\n        ------\n        AssertationError\n            If neither group_id nor group_name is provided.\n            If neither `category_name` nor `category_id` are specified.\n\n        \"\"\"\n\n        from furthrmind.collection import Category\n\n        assert group_name or group_id, \"Either group_name or group_id must be specified\"\n        assert category_name or category_id, \"Either category name or id must be specified\"\n\n        data = cls._prepare_data_for_create(name, group_name, group_id, project_id)\n\n        category_dict = {}\n        if category_name:\n            category_dict[\"name\"] = category_name\n        if category_id:\n            category_dict[\"id\"] = category_id\n\n        data[\"category\"] = category_dict\n        id = cls._post(data, project_id)\n\n        if \"id\" not in category_dict:\n            categories = Category._get_all(project_id)\n            for cat in categories:\n                if cat.name == category_name:\n                    category_dict[\"id\"] = cat.id\n                    break\n\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Parameters\n        ----------\n        data_list : List[Dict]\n            List of dictionaries containing information about the items to be created. Each dictionary should have the\n            following keys:\n                - name: str\n                    The name of the group to be created.\n                - group_name: str\n                    The name of the group where the new item will belong to. Group name can only be considered for groups\n                    that are not subgroups. Either group_name or group_id must be specified.\n                - group_id: int or None\n                    The ID of the group where the new item will belong to. Either group_name or group_id must be specified.\n                - category_name: str\n                    The name of the category that the new item will belong to. Either category_name or category_id must be specified.\n                - category_id: int or None\n                    The ID of the category that the new item will belong to. Either category_name or category_id must be specified.\n        project_id : str, optional\n            Optionally to create researchitems in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list of instances of the researchitem class created.\n\n        Raises\n        ------\n        AssertationError\n            If name not specified\n            If neither category name nor ID is specified.\n            If neither group_id nor group_name is provided.\n\n\n        \"\"\"\n\n        new_list = []\n        category_id_not_present = False\n\n        for data in data_list:\n            category_name = data.get('category_name')\n            category_id = data.get('category_id')\n            assert category_name or category_id, \"Either category name or id must be specified\"\n\n            # raises an error if name not specified or if neither group_name nor group_id is provided\n            temp_data = cls._prepare_data_for_create(data.get(\"name\"), data.get(\"group_name\"), data.get(\"group_id\"),\n                                                     project_id)\n\n            category_dict = {}\n            if category_name:\n                category_dict[\"name\"] = category_name\n            if category_id:\n                category_dict[\"id\"] = category_id\n\n            temp_data[\"category\"] = category_dict\n            new_list.append(temp_data)\n            if not \"id\" in category_dict:\n                category_id_not_present = True\n\n        id_list = cls._post(new_list, project_id, force_list=True)\n        category_mapping = {}\n        if category_id_not_present:\n            categories = Category._get_all(project_id)\n            category_mapping = {cat.name: cat for cat in categories}\n\n        for data, id in zip(new_list, id_list):\n            data[\"id\"] = id\n            if \"id\" not in data[\"category\"]:\n                cat_id = category_mapping.get(data[\"category\"][\"name\"])\n                data[\"category\"][\"id\"] = cat_id\n\n        return new_list\n\n    def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\" ) -&gt; \"DataTable\":\n        \"\"\"\n        Method to create a new datatable within this researchitem. Add the created datatable to the datatables attribute\n\n        Parameters\n        ----------\n        name : str\n            Name of the datatable.\n        columns : List[Dict]\n            A list of columns that should be added to the datatable. Each column is represented as a dictionary with the following keys:\n            - name : str\n                Name of the column.\n            - type : str\n                Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n            - data : Union[List[Union[str, float]], pandas.Series]\n                List of column values. Data must fit the specified type of the column.\n                For Text columns, the items must be convertable to strings\n                For Numeric columns, the items must be convertable to floats.\n                Can be a list or a pandas.Series.\n            - unit : dict or str\n                Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n                representing the name or id of the unit.\n        project_id : str, optional\n            Optionally, specify the id of another project to create the datatable in.\n\n        Returns\n        -------\n        DataTable\n            An instance of the DataTable class representing the created datatable.\n\n        \"\"\"\n\n        from furthrmind.collection import DataTable\n        datatable = DataTable.create(name, researchitem_id=self.id, columns=columns, project_id=project_id)\n\n        new_datatable = list(self.datatables)\n        new_datatable.append(datatable)\n        self.datatables = new_datatable\n\n        return datatable\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_datatable","title":"<code>add_datatable(name, columns, project_id='')</code>","text":"<p>Method to create a new datatable within this researchitem. Add the created datatable to the datatables attribute</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the datatable.</p> required <code>columns</code> <code>List[Dict]</code> <p>A list of columns that should be added to the datatable. Each column is represented as a dictionary with the following keys: - name : str     Name of the column. - type : str     Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type. - data : Union[List[Union[str, float]], pandas.Series]     List of column values. Data must fit the specified type of the column.     For Text columns, the items must be convertable to strings     For Numeric columns, the items must be convertable to floats.     Can be a list or a pandas.Series. - unit : dict or str     Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string     representing the name or id of the unit.</p> required <code>project_id</code> <code>str</code> <p>Optionally, specify the id of another project to create the datatable in.</p> <code>''</code> <p>Returns:</p> Type Description <code>DataTable</code> <p>An instance of the DataTable class representing the created datatable.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>def add_datatable(self, name: str, columns: List[Dict], project_id: str = \"\" ) -&gt; \"DataTable\":\n    \"\"\"\n    Method to create a new datatable within this researchitem. Add the created datatable to the datatables attribute\n\n    Parameters\n    ----------\n    name : str\n        Name of the datatable.\n    columns : List[Dict]\n        A list of columns that should be added to the datatable. Each column is represented as a dictionary with the following keys:\n        - name : str\n            Name of the column.\n        - type : str\n            Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type.\n        - data : Union[List[Union[str, float]], pandas.Series]\n            List of column values. Data must fit the specified type of the column.\n            For Text columns, the items must be convertable to strings\n            For Numeric columns, the items must be convertable to floats.\n            Can be a list or a pandas.Series.\n        - unit : dict or str\n            Unit of the column. It can be represented as either a dictionary with 'id' or 'name', or a string\n            representing the name or id of the unit.\n    project_id : str, optional\n        Optionally, specify the id of another project to create the datatable in.\n\n    Returns\n    -------\n    DataTable\n        An instance of the DataTable class representing the created datatable.\n\n    \"\"\"\n\n    from furthrmind.collection import DataTable\n    datatable = DataTable.create(name, researchitem_id=self.id, columns=columns, project_id=project_id)\n\n    new_datatable = list(self.datatables)\n    new_datatable.append(datatable)\n    self.datatables = new_datatable\n\n    return datatable\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_file","title":"<code>add_file(file_path='', file_name='', file_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path of the file that should be uploaded.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Optionally specify the file name if not the original file name should be used.</p> <code>''</code> <code>file_id</code> <code>str</code> <p>ID of the file.</p> <code>''</code> <p>Returns:</p> Type Description <code>File</code> <p>The file object that has been added.</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If neither file path nor file_id is specified.</p> <code>ValueError</code> <p>If the file path specified does not exist.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_file(self, file_path: str = \"\", file_name: str = \"\", file_id: str = \"\") -&gt; \"File\":\n    \"\"\"\n    Parameters\n    ----------\n    file_path : str, optional\n        File path of the file that should be uploaded.\n    file_name : str, optional\n        Optionally specify the file name if not the original file name should be used.\n    file_id : str, optional\n        ID of the file.\n\n    Returns\n    -------\n    File\n        The file object that has been added.\n\n    Raises\n    ------\n    AssertationError\n        If neither file path nor file_id is specified.\n    ValueError\n        If the file path specified does not exist.\n    \"\"\"\n\n\n    from furthrmind.file_loader import FileLoader\n    from .file import File\n\n    assert file_path or file_id, \"File_path or file_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if not file_id:\n        assert file_path, \"File path must be specified\"\n        if not os.path.isfile(file_path):\n            raise ValueError(\"File does not exist\")\n\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n        file_id, file_name = fl.uploadFile(file_path, file_name)\n        file_data = {\"id\": file_id,\n                     \"name\": file_name}\n    else:\n        file_data = {\"id\": file_id}\n\n    file_list = [{\"id\": f.id} for f in self.files]\n    file_list.append(file_data)\n    post_data = {\"id\": self.id, \"files\": file_list}\n\n    id = self._post(post_data)\n    file = File(data=file_data)\n    new_file_list = list(self.files)\n    new_file_list.append(file)\n    self.files = new_file_list\n    return file\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_linked_experiment","title":"<code>add_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>This method is used to link an experiment to the current item. If the experiment is already linked to the item, no action is taken.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    This method is used to link an experiment to the current item. If the experiment is already linked to the item,\n    no action is taken.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n    experiment_name : str, optional\n        The name of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n\n    Returns\n    -------\n    str\n        The ID of the item.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name=experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n    else:\n        exp = Experiment.get(experiment_id)\n\n    experiment_id_list = [item.id for item in self.linked_experiments]\n    if experiment_id in experiment_id_list:\n        return self.id\n\n    experiment_id_list.append(experiment_id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    new_linked_experiments = list(self.linked_experiments)\n    new_linked_experiments.append(exp)\n    self.linked_experiments = new_linked_experiments\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_linked_researchitem","title":"<code>add_linked_researchitem(researchitem_id)</code>","text":"<p>Method is to link a research item to the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The id of the research item to be linked. If not specified, the method will raise an assertion error.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The id of the current research item.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If researchitem_id is not specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method is to link a research item to the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The id of the research item to be linked. If not specified, the method will raise an assertion error.\n\n    Returns\n    -------\n    str\n        The id of the current research item.\n\n    Raises\n    ------\n    AssertionError\n        If researchitem_id is not specified.\n\n    \"\"\"\n\n    from furthrmind.collection import ResearchItem\n    assert researchitem_id, \"researchitem_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    for cat in self.linked_researchitems:\n        researchitem_id_list.extend([ri_id.id for ri_id in self.linked_researchitems[cat]])\n\n    if researchitem_id in researchitem_id_list:\n        return self.id\n\n    researchitem_id_list.append(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    ri = ResearchItem.get(id=researchitem_id)\n    research_item_dict = dict(self.linked_researchitems)\n    if ri.category.name in self.linked_researchitems:\n        new_linked_researchitems = list(self.linked_researchitems[ri.category.name])\n    else:\n        new_linked_researchitems = []\n\n    new_linked_researchitems.append(ri)\n    research_item_dict[ri.category.name] = new_linked_researchitems\n    self.linked_researchitems = research_item_dict\n\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_linked_sample","title":"<code>add_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to link a sample to the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>id to the sample you want to link, either id or name must be given</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>name of the sample you want to link, either name or id must be given</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the id of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample found with the given name</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to link a sample to the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        id to the sample you want to link, either id or name must be given\n    sample_name : str, optional\n        name of the sample you want to link, either name or id must be given\n\n    Returns\n    -------\n    str\n        the id of the item\n\n    Raises\n    ------\n    ValueError\n        If no sample found with the given name\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n    else:\n        s = Sample.get(sample_id)\n\n    sample_id_list = [item.id for item in self.linked_samples]\n    if sample_id in sample_id_list:\n        return self.id\n\n    sample_id_list.append(sample_id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n\n    self._post(data=data)\n    new_linked_samples = list(self.linked_samples)\n    new_linked_samples.append(s)\n    self.linked_samples = new_linked_samples\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.create","title":"<code>create(name, group_name='', group_id='', category_name='', category_id='', project_id=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to be created.</p> required <code>group_name</code> <code>str</code> <p>The name of the group where the new item will belong to. Group name can only be considered for groups that are not subgroups. Either <code>group_name</code> or <code>group_id</code> must be specified.</p> <code>''</code> <code>group_id</code> <code>str</code> <p>The id of the group where the new item will belong to. Either <code>group_name</code> or <code>group_id</code> must be specified.</p> <code>''</code> <code>category_name</code> <code>str</code> <p>The name of the category that the new item will belong to. Either <code>category_name</code> or <code>category_id</code> must be specified.</p> <code>''</code> <code>category_id</code> <code>str</code> <p>The id of the category that the new item will belong to. Either <code>category_name</code> or <code>category_id</code> must be specified.</p> <code>''</code> <code>project_id</code> <code>object</code> <p>Optionally create a researchitem in another project as the furthrmind sdk was initiated with.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>instance of the researchitem class</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If neither group_id nor group_name is provided. If neither <code>category_name</code> nor <code>category_id</code> are specified.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, group_name: str = \"\", group_id: str = \"\", category_name: str = \"\", category_id: str = \"\",\n           project_id=None) -&gt; Self:\n    \"\"\"\n    Parameters\n    ----------\n    name : str\n        The name of the item to be created.\n    group_name : str, optional\n        The name of the group where the new item will belong to. Group name can only be considered for groups that\n        are not subgroups. Either `group_name` or `group_id` must be specified.\n    group_id : str, optional\n        The id of the group where the new item will belong to. Either `group_name` or `group_id` must be specified.\n    category_name : str, optional\n        The name of the category that the new item will belong to. Either `category_name` or `category_id` must be specified.\n    category_id : str, optional\n        The id of the category that the new item will belong to. Either `category_name` or `category_id` must be specified.\n    project_id : object, optional\n        Optionally create a researchitem in another project as the furthrmind sdk was initiated with.\n\n    Returns\n    -------\n    Self\n        instance of the researchitem class\n\n    Raises\n    ------\n    AssertationError\n        If neither group_id nor group_name is provided.\n        If neither `category_name` nor `category_id` are specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Category\n\n    assert group_name or group_id, \"Either group_name or group_id must be specified\"\n    assert category_name or category_id, \"Either category name or id must be specified\"\n\n    data = cls._prepare_data_for_create(name, group_name, group_id, project_id)\n\n    category_dict = {}\n    if category_name:\n        category_dict[\"name\"] = category_name\n    if category_id:\n        category_dict[\"id\"] = category_id\n\n    data[\"category\"] = category_dict\n    id = cls._post(data, project_id)\n\n    if \"id\" not in category_dict:\n        categories = Category._get_all(project_id)\n        for cat in categories:\n            if cat.name == category_name:\n                category_dict[\"id\"] = cat.id\n                break\n\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.create_many","title":"<code>create_many(data_list, project_id='')</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing information about the items to be created. Each dictionary should have the following keys:     - name: str         The name of the group to be created.     - group_name: str         The name of the group where the new item will belong to. Group name can only be considered for groups         that are not subgroups. Either group_name or group_id must be specified.     - group_id: int or None         The ID of the group where the new item will belong to. Either group_name or group_id must be specified.     - category_name: str         The name of the category that the new item will belong to. Either category_name or category_id must be specified.     - category_id: int or None         The ID of the category that the new item will belong to. Either category_name or category_id must be specified.</p> required <code>project_id</code> <code>str</code> <p>Optionally to create researchitems in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list of instances of the researchitem class created.</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If name not specified If neither category name nor ID is specified. If neither group_id nor group_name is provided.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Parameters\n    ----------\n    data_list : List[Dict]\n        List of dictionaries containing information about the items to be created. Each dictionary should have the\n        following keys:\n            - name: str\n                The name of the group to be created.\n            - group_name: str\n                The name of the group where the new item will belong to. Group name can only be considered for groups\n                that are not subgroups. Either group_name or group_id must be specified.\n            - group_id: int or None\n                The ID of the group where the new item will belong to. Either group_name or group_id must be specified.\n            - category_name: str\n                The name of the category that the new item will belong to. Either category_name or category_id must be specified.\n            - category_id: int or None\n                The ID of the category that the new item will belong to. Either category_name or category_id must be specified.\n    project_id : str, optional\n        Optionally to create researchitems in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list of instances of the researchitem class created.\n\n    Raises\n    ------\n    AssertationError\n        If name not specified\n        If neither category name nor ID is specified.\n        If neither group_id nor group_name is provided.\n\n\n    \"\"\"\n\n    new_list = []\n    category_id_not_present = False\n\n    for data in data_list:\n        category_name = data.get('category_name')\n        category_id = data.get('category_id')\n        assert category_name or category_id, \"Either category name or id must be specified\"\n\n        # raises an error if name not specified or if neither group_name nor group_id is provided\n        temp_data = cls._prepare_data_for_create(data.get(\"name\"), data.get(\"group_name\"), data.get(\"group_id\"),\n                                                 project_id)\n\n        category_dict = {}\n        if category_name:\n            category_dict[\"name\"] = category_name\n        if category_id:\n            category_dict[\"id\"] = category_id\n\n        temp_data[\"category\"] = category_dict\n        new_list.append(temp_data)\n        if not \"id\" in category_dict:\n            category_id_not_present = True\n\n    id_list = cls._post(new_list, project_id, force_list=True)\n    category_mapping = {}\n    if category_id_not_present:\n        categories = Category._get_all(project_id)\n        category_mapping = {cat.name: cat for cat in categories}\n\n    for data, id in zip(new_list, id_list):\n        data[\"id\"] = id\n        if \"id\" not in data[\"category\"]:\n            cat_id = category_mapping.get(data[\"category\"][\"name\"])\n            data[\"category\"][\"id\"] = cat_id\n\n    return new_list\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.get","title":"<code>get(id='', shortid='', name='', category_name='', category_id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get  one researchitem by its id, short_id or name. If requested by name, also category_name or category_id is required. If called on an instance of the class, the id of the class is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the requested research item.</p> <code>''</code> <code>shortid</code> <code>str</code> <p>The short id of the requested research item.</p> <code>''</code> <code>name</code> <code>str</code> <p>The name of the requested research item.</p> <code>''</code> <code>category_name</code> <code>str</code> <p>The name of the category the research item belongs to.</p> <code>''</code> <code>category_id</code> <code>str</code> <p>The id of the category the research item belongs to.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get a researchitem from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the researchitem class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If used as a class method and neither id, shortid, nor name is provided. If used as a class method and name is provided but neither category_name nor category_id is provided.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", shortid: str = \"\", name: str = \"\", category_name: str = \"\", category_id: str = \"\",\n        project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get  one researchitem by its id, short_id or name. If requested by name, also category_name or\n    category_id is required.\n    If called on an instance of the class, the id of the class is used\n\n    Parameters\n    ----------\n    id : str, optional\n        The id of the requested research item.\n\n    shortid : str, optional\n        The short id of the requested research item.\n\n    name : str, optional\n        The name of the requested research item.\n\n    category_name : str, optional\n        The name of the category the research item belongs to.\n\n    category_id : str, optional\n        The id of the category the research item belongs to.\n\n    project_id : str, optional\n        Optionally to get a researchitem from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        Instance of the researchitem class.\n\n    Raises\n    ------\n    AssertionError\n        If used as a class method and neither id, shortid, nor name is provided.\n        If used as a class method and name is provided but neither category_name nor category_id is provided.\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id or shortid or name, AssertionError(\"Either id, shortid or name must be given\")\n        if not id and name:\n            assert category_name or category_id, AssertionError(\"Either category name or id must be given\")\n\n    return cls._get(id=id, shortid=shortid, name=name,\n                    category_name=category_name, category_id=category_id, project_id=project_id)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all researchitems belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get researchitems from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list containing instances of the researchitem class.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all researchitems belonging to one project\n\n    Parameters\n    ----------\n    project_id: str\n        Optionally to get researchitems from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list containing instances of the researchitem class.\n    \"\"\"\n\n    return cls._get_all(project_id)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.get_many","title":"<code>get_many(ids=(), shortids=(), names=(), category_name=None, category_id=None, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to get many researchitems by ids or shortids. If requested by names, also category_name or category_id is required. If requested by name items from one category can be requested at a time.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of experiment ids.</p> <code>()</code> <code>shortids</code> <code>List[str]</code> <p>List of experiment short ids.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of experiment names.</p> <code>()</code> <code>category_name</code> <code>str</code> <p>Name of the category the research item belongs to.</p> <code>None</code> <code>category_id</code> <code>str</code> <p>Id of the category the research item belongs to.</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Optionally to get researchitems from another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the researchitem class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>ids, shortids, nor names must be provided. If names is provided but neither category_name nor category_id is provided.</p> Source code in <code>furthrmind/collection/researchitem.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n             category_name=None, category_id=None, project_id=None) -&gt; List[Self]:\n    \"\"\"\n    Method to get many researchitems by ids or shortids. If requested by names, also category_name or category_id\n    is required. If requested by name items from one category can be requested at a time.\n\n    Parameters\n    ----------\n    ids : List[str]\n         List of experiment ids.\n    shortids : List[str]\n         List of experiment short ids.\n    names : List[str]\n         List of experiment names.\n    category_name : str, optional\n         Name of the category the research item belongs to.\n    category_id : str, optional\n         Id of the category the research item belongs to.\n    project_id : str, optional\n         Optionally to get researchitems from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n         List of instances of the researchitem class.\n\n    Raises\n    ------\n    AssertionError\n        ids, shortids, nor names must be provided.\n        If names is provided but neither category_name nor category_id is provided.\n\n    \"\"\"\n\n    assert ids or shortids or names, AssertionError(\"Either ids, shortids or names must be given\")\n    if names:\n        assert category_name or category_id, AssertionError(\"Either category_name or category_id must be given\")\n\n    return cls._get_many(ids, shortids, names, category_name, category_id, project_id=project_id)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.remove_file","title":"<code>remove_file(file_id='', file_name='')</code>","text":"<p>Method to remove a file from the current item</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>str</code> <p>ID of the file that should be removed. Either <code>file_id</code> or <code>file_name</code> must be specified.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be removed.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>file_object</code> <code>dict</code> <p>Object representing the removed file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no file is found with the given <code>file_id</code> or <code>file_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_file(self, file_id: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Method to remove a file from the current item\n\n    Parameters\n    ----------\n    file_id: str, optional\n        ID of the file that should be removed. Either `file_id` or `file_name` must be specified.\n    file_name: str, optional\n        Name of the file to be removed.\n\n    Returns\n    -------\n    file_object: dict\n        Object representing the removed file.\n\n    Raises\n    ------\n    ValueError\n        If no file is found with the given `file_id` or `file_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    new_file_list = []\n    file_to_be_removed = None\n    for file in self.files:\n        found = False\n        if file_id:\n            found = True\n            if file.id == file_id:\n                file_to_be_removed = file\n        elif file_name:\n            found = True\n            if file.name == file_name:\n                file_to_be_removed = file\n        if not found:\n            new_file_list.append(file)\n\n    if not file_to_be_removed:\n        raise ValueError(\"No file found with the given file_id or file_name\")\n\n    self.files = new_file_list\n    file_list = [{\"id\": f.id} for f in new_file_list]\n    post_data = {\"id\": self.id, \"files\": file_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.remove_linked_experiment","title":"<code>remove_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>Method to remove a linked experiment from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> <code>AssertionError</code> <p>If neither <code>experiment_id</code> nor <code>experiment_name</code> is specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    Method to remove a linked experiment from the current item.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n    experiment_name : str, optional\n        The name of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n    AssertionError\n        If neither `experiment_id` nor `experiment_name` is specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name = experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n\n    experiment_id_list = []\n    new_linked_items = []\n    for item in self.linked_experiments:\n        if item.id == experiment_id:\n            continue\n        new_linked_items.append(item)\n        experiment_id_list.append(item.id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    self.linked_experiments = new_linked_items\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.remove_linked_researchitem","title":"<code>remove_linked_researchitem(researchitem_id)</code>","text":"<p>Method to remove a linked researchitem from the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The ID of the research item you want to unlink</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method to remove a linked researchitem from the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The ID of the research item you want to unlink\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n    \"\"\"\n\n    assert researchitem_id, \"Either experiment_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    new_linked_items = {}\n    for cat in self.linked_researchitems:\n        for item in self.linked_researchitems[cat]:\n            if item.id == researchitem_id:\n                continue\n            if cat not in new_linked_items:\n                new_linked_items[cat] = []\n            new_linked_items[cat].append(item)\n            researchitem_id_list.append(item.id)\n\n    if researchitem_id in researchitem_id_list:\n        researchitem_id_list.remove(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    self.linked_researchitems = new_linked_items\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.remove_linked_sample","title":"<code>remove_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to remove a linked sample from the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>The id of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>The name of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample is found with the given name.</p> Notes <p>This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to remove a linked sample from the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        The id of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n    sample_name : str, optional\n        The name of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n\n    Returns\n    -------\n    str\n        The id of the item.\n\n    Raises\n    ------\n    ValueError\n        If no sample is found with the given name.\n\n    Notes\n    -----\n    This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n\n    sample_id_list = []\n    new_linked_items = []\n    for item in self.linked_samples:\n        if item.id == sample_id:\n            continue\n        new_linked_items.append(item)\n        sample_id_list.append(item.id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n    self._post(data=data)\n    self.linked_samples = new_linked_items\n    return self.id\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"researchitem/#furthrmind.collection.researchitem.ResearchItem.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"sample/","title":"Sample","text":""},{"location":"sample/#furthrmind.collection.sample.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>BaseClassWithFieldData</code>, <code>BaseClassWithFiles</code>, <code>BaseClassWithGroup</code>, <code>BaseClassWithLinking</code>, <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the sample</p> <code>name</code> <code>str</code> <p>name of the sample</p> <code>shortid</code> <code>str</code> <p>shortid of the sample</p> <code>files</code> <code>List[File]</code> <p>List of files belonging to this sample. See File for more information.</p> <code>fielddata</code> <code>List[FieldData]</code> <p>List of field data belonging to this sample. See FieldData for more information.</p> <code>linked_samples</code> <code>List[Sample]</code> <p>This list contains 'sample' objects linked to the current sample. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'sample' objects, see the provided Sample.</p> <code>linked_experiments</code> <code>List[Experiment]</code> <p>This list contains 'experiment' objects linked to the current sample. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'experiment' objects, see the provided Experiment.</p> <code>linked_researchitems</code> <code>Dict[str, List[ResearchItem]]</code> <p>This is a dictionary with category name as keys and lists with the corresponding <code>researchitem</code> objects as values. The <code>researchitem</code> objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'researchitem' objects, see the provided ResearchItem.</p> <code>groups</code> <code>List[Group]</code> <p>This list contains 'group' objects the sample belongs to. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'group' objects, see the provided Group.</p> <code>datatables</code> <code>List[DataTable]</code> <p>This list contains 'datatable' objects that belong to this sample. These objects are partially fetched, providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'. Refer to nested objects in Getting Started for further details. For a comprehensive understanding of 'datatable' objects, see the provided DataTable.</p> <code>_fetched</code> <code>bool</code> <p>This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only the name and ID are present.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>class Sample(BaseClassWithFieldData,\n             BaseClassWithFiles, BaseClassWithGroup,\n             BaseClassWithLinking, BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the sample\n    name : str\n        name of the sample\n    shortid : str\n        shortid of the sample\n    files : List[File]\n        List of files belonging to this sample. See [File](file.md) for more information.\n    fielddata : List[FieldData]\n        List of field data belonging to this sample. See [FieldData](fielddata.md) for more information.\n    linked_samples : List[Sample]\n        This list contains 'sample' objects linked to the current sample. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'sample'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'sample' objects, see the provided [Sample](sample.md).\n    linked_experiments : List[Experiment]\n        This list contains 'experiment' objects linked to the current sample. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'experiment'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'experiment' objects, see the provided [Experiment](experiment.md).\n    linked_researchitems : Dict[str, List[ResearchItem]]\n        This is a dictionary with category name as keys and lists with the corresponding `researchitem` objects as values.\n        The `researchitem` objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'researchitem'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'researchitem' objects, see the provided [ResearchItem](researchitem.md).\n    groups : List[Group]\n        This list contains 'group' objects the sample belongs to. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'group'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'group' objects, see the provided [Group](group.md).\n    datatables : List[DataTable]\n        This list contains 'datatable' objects that belong to this sample. These objects are partially fetched,\n        providing only the name and ID. To retrieve the entire object, invoke the 'get()' method on the 'datatable'.\n        Refer to nested objects in [Getting Started](index.md) for further details. For a comprehensive understanding of\n        'datatable' objects, see the provided [DataTable](datatable.md).\n    _fetched : bool\n        This is a Boolean attribute indicating whether all attributes have been retrieved from the server or only\n        the name and ID are present.\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    neglect = False\n    shortid = \"\"\n    files: List[\"File\"] = []\n    fielddata: List[\"FieldData\"] = []\n    linked_experiments: List[\"Experiment\"] = []\n    linked_samples: List[Self] = []\n    linked_researchitems: Dict[str, List[\"ResearchItem\"]] = {}\n    groups: List[\"Group\"] = []\n    datatables: List[\"DataTable\"] = []\n\n    _attr_definition = {\n        \"files\": {\"class\": \"File\"},\n        \"fielddata\": {\"class\": \"FieldData\"},\n        \"groups\": {\"class\": \"Group\"},\n        \"linked_samples\": {\"class\": \"Sample\"},\n        \"linked_experiments\": {\"class\": \"Experiment\"},\n        \"linked_researchitems\": {\"class\": \"ResearchItem\", \"nested_dict\": True},\n        \"datatables\": {\"class\": \"DataTable\"}\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n        # create instance methods for certain class_methods\n        instance_methods = [\"get\"]\n        instance_overload(self, instance_methods)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Sample.fm.get_project_url(project_id)\n        url = f\"{project_url}/samples/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/samples/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/samples\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/samples\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = \"\", name: str = \"\", shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n        \"\"\"\n        Method to get one sample by its id, short_id, or name.\n        If called on an instance of the class, the id of the instance is used\n\n        Parameters\n        ----------\n        id : str\n            The id or short_id of the requested sample.\n        name : str\n            The name of the requested sample.\n        shortid : str\n            The shortid of the requested sample.\n        project_id : str, optional\n            Optionally to get the sample from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            An instance of the sample class.\n\n        Raises\n        ------\n        AssertionError\n            If called as a class method and no id, shortid, or name is specified.\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id or name or shortid, \"Either id, shortid, or name must be specified\"\n\n        return cls._get(id, shortid, name, project_id=project_id)\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n                 project_id: str = None) -&gt; List[Self]:\n        \"\"\"\n        Method to get many samples by its ids, short_ids, or names.\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of sample ids to filter samples by.\n        shortids : List[str]\n            List of short ids to filter samples by.\n        names : List[str]\n            List of names to filter samples by.\n        project_id : str, optional\n            Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the sample class.\n\n        Raises\n        ------\n        AssertionError\n            If neither ids, shortids, nor names are specified.\n\n        \"\"\"\n\n        assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n        return cls._get_many(ids, shortids, names, project_id=project_id)\n\n    @classmethod\n    def get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n        \"\"\"\n        Method to get all samples belonging to one project\n\n        Parameters\n        ----------\n        project_id : str, optional\n            Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the `Sample` class representing the fetched samples.\n        \"\"\"\n\n        return cls._get_all(project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, group_name: str = None, group_id: str = None, project_id: str = None) -&gt; Self:\n        \"\"\"\n        Method to create a new sample.\n\n        Parameters\n        ----------\n        name : str\n            The name of the sample to be created.\n\n        group_name : str, optional\n            The name of the group where the new item will belong to. Group name can only be considered for groups that are not subgroups.\n            Either group_name or group_id must be specified.\n\n        group_id : int, optional\n            The ID of the group where the new item will belong to.\n            Either group_name or group_id must be specified.\n        project_id : str, optional\n            Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        Self\n            An instance of the sample class.\n\n        Raises\n        ------\n        AssertionError\n            If neither group_name nor group_id is specified.\n\n        \"\"\"\n\n        return Sample._create(name, group_name, group_id, project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = None) -&gt; Self:\n        \"\"\"\n        Method to create many samples.\n\n        Parameters\n        ----------\n        data_list : List[Dict]\n            A list of dictionaries representing the data for creating multiple samples. Each dictionary should have the following keys:\n            - 'name': The name of the sample to be created.\n            - 'group_name': The name of the group where the new item will belong to. The 'group_name' can only be considered for groups\n                            that are not subgroups. Either 'group_name' or 'group_id' must be specified.\n            - 'group_id': The id of the group where the new item will belong to. Either 'group_name' or 'group_id' must be specified.\n\n        project_id : str, optional\n            Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Sample]\n            A list of instances of the 'Sample' class, representing the created samples.\n\n        Raises\n        ------\n        AssertionError\n            If neither group_name nor group_id is specified.\n\n        \"\"\"\n\n        return Sample._create_many(data_list, project_id)\n\n    def add_datatable(self, name: str, columns: List[Dict] = None, project_id: str = None) -&gt; \"DataTable\":\n        \"\"\"\n        Method to create a new datatable and add within a sample.\n\n        Parameters\n        ----------\n        name: str\n            Name of the datatable\n        columns: List[Dict], optional\n            A list of columns that should be added to the datatable. Each column is represented by a dictionary with the following keys:\n            - name: str\n                Name of the column\n            - type: str\n                Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type. For Text, all data\n                will be converted to a string and for Numeric, all data will be converted to a float (if possible)\n            - data: List\n                List of column values. Values must fit the specified column type\n            - unit: Union[Dict, str], optional\n                Dictionary with an id or name, or a name as a string, or an id as a string representing the unit\n        project_id: str, optional\n            Optionally create the datatable in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        DataTable\n            Instance of the datatable class\n        \"\"\"\n\n        from furthrmind.collection import DataTable\n        datatable = DataTable.create(name, sample_id=self.id, columns=columns, project_id=project_id)\n\n        new_datatable = list(self.datatables)\n        new_datatable.append(datatable)\n        self.datatables = new_datatable\n\n        return datatable\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_datatable","title":"<code>add_datatable(name, columns=None, project_id=None)</code>","text":"<p>Method to create a new datatable and add within a sample.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the datatable</p> required <code>columns</code> <code>List[Dict]</code> <p>A list of columns that should be added to the datatable. Each column is represented by a dictionary with the following keys: - name: str     Name of the column - type: str     Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type. For Text, all data     will be converted to a string and for Numeric, all data will be converted to a float (if possible) - data: List     List of column values. Values must fit the specified column type - unit: Union[Dict, str], optional     Dictionary with an id or name, or a name as a string, or an id as a string representing the unit</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Optionally create the datatable in another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>DataTable</code> <p>Instance of the datatable class</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>def add_datatable(self, name: str, columns: List[Dict] = None, project_id: str = None) -&gt; \"DataTable\":\n    \"\"\"\n    Method to create a new datatable and add within a sample.\n\n    Parameters\n    ----------\n    name: str\n        Name of the datatable\n    columns: List[Dict], optional\n        A list of columns that should be added to the datatable. Each column is represented by a dictionary with the following keys:\n        - name: str\n            Name of the column\n        - type: str\n            Type of the column. Either \"Text\" or \"Numeric\". Data must fit the specified type. For Text, all data\n            will be converted to a string and for Numeric, all data will be converted to a float (if possible)\n        - data: List\n            List of column values. Values must fit the specified column type\n        - unit: Union[Dict, str], optional\n            Dictionary with an id or name, or a name as a string, or an id as a string representing the unit\n    project_id: str, optional\n        Optionally create the datatable in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    DataTable\n        Instance of the datatable class\n    \"\"\"\n\n    from furthrmind.collection import DataTable\n    datatable = DataTable.create(name, sample_id=self.id, columns=columns, project_id=project_id)\n\n    new_datatable = list(self.datatables)\n    new_datatable.append(datatable)\n    self.datatables = new_datatable\n\n    return datatable\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_field","title":"<code>add_field(field_name='', field_type='', field_id='', value=None, unit=None)</code>","text":"<p>Method to add a field to the current item</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of field that should be added. If fieldname provided, also fieldtype must be specified. Either fieldname and fieldtype or field_id must be specified.</p> <code>''</code> <code>field_type</code> <code>str</code> <p>Type of field. Must be one of:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> <code>''</code> <code>field_id</code> <code>str</code> <p>Id of field that should be added.</p> <code>''</code> <code>value</code> <code>Any</code> <p>Value of the field. The data type of the value depends on the field_type:</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> <code>None</code> <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> <code>None</code> <p>Returns:</p> Type Description <code>FieldData</code> <p>The new FieldData object that was created.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_field(self, field_name: str = \"\", field_type: str = \"\", field_id: str = \"\",\n              value: Any = None, unit: Union[Dict, str] = None) -&gt; \"FieldData\":\n    \"\"\"\n    Method to add a field to the current item\n\n    Parameters\n    ----------\n    field_name : str\n        Name of field that should be added. If fieldname provided, also fieldtype must be specified.\n        Either fieldname and fieldtype or field_id must be specified.\n    field_type : str\n        Type of field. Must be one of:\n\n        - Numeric fields: numeric, numeric-field, numeric_field\n        - Date fields: date, date_field, date-field, datefield\n        - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n        - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n        - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n        - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n        - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n    field_id : str\n        Id of field that should be added.\n    value : Any\n        Value of the field. The data type of the value depends on the field_type:\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n\n    Returns\n    -------\n    FieldData\n        The new FieldData object that was created.\n\n    \"\"\"\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata = FieldData.create(field_name, field_type, field_id, value, unit)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.append(fielddata)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_file","title":"<code>add_file(file_path='', file_name='', file_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>File path of the file that should be uploaded.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Optionally specify the file name if not the original file name should be used.</p> <code>''</code> <code>file_id</code> <code>str</code> <p>ID of the file.</p> <code>''</code> <p>Returns:</p> Type Description <code>File</code> <p>The file object that has been added.</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If neither file path nor file_id is specified.</p> <code>ValueError</code> <p>If the file path specified does not exist.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_file(self, file_path: str = \"\", file_name: str = \"\", file_id: str = \"\") -&gt; \"File\":\n    \"\"\"\n    Parameters\n    ----------\n    file_path : str, optional\n        File path of the file that should be uploaded.\n    file_name : str, optional\n        Optionally specify the file name if not the original file name should be used.\n    file_id : str, optional\n        ID of the file.\n\n    Returns\n    -------\n    File\n        The file object that has been added.\n\n    Raises\n    ------\n    AssertationError\n        If neither file path nor file_id is specified.\n    ValueError\n        If the file path specified does not exist.\n    \"\"\"\n\n\n    from furthrmind.file_loader import FileLoader\n    from .file import File\n\n    assert file_path or file_id, \"File_path or file_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if not file_id:\n        assert file_path, \"File path must be specified\"\n        if not os.path.isfile(file_path):\n            raise ValueError(\"File does not exist\")\n\n        fl = FileLoader(self.fm.host, self.fm.api_key)\n        file_id, file_name = fl.uploadFile(file_path, file_name)\n        file_data = {\"id\": file_id,\n                     \"name\": file_name}\n    else:\n        file_data = {\"id\": file_id}\n\n    file_list = [{\"id\": f.id} for f in self.files]\n    file_list.append(file_data)\n    post_data = {\"id\": self.id, \"files\": file_list}\n\n    id = self._post(post_data)\n    file = File(data=file_data)\n    new_file_list = list(self.files)\n    new_file_list.append(file)\n    self.files = new_file_list\n    return file\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_linked_experiment","title":"<code>add_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>This method is used to link an experiment to the current item. If the experiment is already linked to the item, no action is taken.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment to link. Either <code>experiment_id</code> or <code>experiment_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    This method is used to link an experiment to the current item. If the experiment is already linked to the item,\n    no action is taken.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n    experiment_name : str, optional\n        The name of the experiment to link. Either `experiment_id` or `experiment_name` must be provided.\n\n    Returns\n    -------\n    str\n        The ID of the item.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name=experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n    else:\n        exp = Experiment.get(experiment_id)\n\n    experiment_id_list = [item.id for item in self.linked_experiments]\n    if experiment_id in experiment_id_list:\n        return self.id\n\n    experiment_id_list.append(experiment_id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    new_linked_experiments = list(self.linked_experiments)\n    new_linked_experiments.append(exp)\n    self.linked_experiments = new_linked_experiments\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_linked_researchitem","title":"<code>add_linked_researchitem(researchitem_id)</code>","text":"<p>Method is to link a research item to the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The id of the research item to be linked. If not specified, the method will raise an assertion error.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The id of the current research item.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If researchitem_id is not specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method is to link a research item to the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The id of the research item to be linked. If not specified, the method will raise an assertion error.\n\n    Returns\n    -------\n    str\n        The id of the current research item.\n\n    Raises\n    ------\n    AssertionError\n        If researchitem_id is not specified.\n\n    \"\"\"\n\n    from furthrmind.collection import ResearchItem\n    assert researchitem_id, \"researchitem_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    for cat in self.linked_researchitems:\n        researchitem_id_list.extend([ri_id.id for ri_id in self.linked_researchitems[cat]])\n\n    if researchitem_id in researchitem_id_list:\n        return self.id\n\n    researchitem_id_list.append(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    ri = ResearchItem.get(id=researchitem_id)\n    research_item_dict = dict(self.linked_researchitems)\n    if ri.category.name in self.linked_researchitems:\n        new_linked_researchitems = list(self.linked_researchitems[ri.category.name])\n    else:\n        new_linked_researchitems = []\n\n    new_linked_researchitems.append(ri)\n    research_item_dict[ri.category.name] = new_linked_researchitems\n    self.linked_researchitems = research_item_dict\n\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_linked_sample","title":"<code>add_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to link a sample to the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>id to the sample you want to link, either id or name must be given</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>name of the sample you want to link, either name or id must be given</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>the id of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample found with the given name</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to link a sample to the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        id to the sample you want to link, either id or name must be given\n    sample_name : str, optional\n        name of the sample you want to link, either name or id must be given\n\n    Returns\n    -------\n    str\n        the id of the item\n\n    Raises\n    ------\n    ValueError\n        If no sample found with the given name\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n    else:\n        s = Sample.get(sample_id)\n\n    sample_id_list = [item.id for item in self.linked_samples]\n    if sample_id in sample_id_list:\n        return self.id\n\n    sample_id_list.append(sample_id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n\n    self._post(data=data)\n    new_linked_samples = list(self.linked_samples)\n    new_linked_samples.append(s)\n    self.linked_samples = new_linked_samples\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.add_many_fields","title":"<code>add_many_fields(data_list)</code>","text":"<p>Method to add many fields to the current item</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:</p> <ul> <li>field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.</li> <li> <p>field_type:     Type of the field. Must be one of the following:</p> <ul> <li>Numeric fields: numeric, numeric-field, numeric_field</li> <li>Date fields: date, date_field, date-field, datefield</li> <li>Text fields: singleline, singlelinefield, text, text-field, text_field, textfield</li> <li>List fields: combobox, comboboxfield, list, list-field, list_field, listfield</li> <li>Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field</li> <li>Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield</li> <li>Calculation fields: calculation, calculation-field, calculation_field, calculationfield</li> </ul> </li> <li> <p>field_id: ID of the field to be added.</p> </li> <li> <p>value: Value of the field. The required format depends on the field_type:</p> <ul> <li>Numeric: float or int, or a string convertible to a float.</li> <li>Date: datetime, date object, Unix timestamp, or string in ISO format.</li> <li>SingleLine: string.</li> <li>ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.</li> <li>MultiLine: Dictionary with content as key, or string.</li> <li>CheckBox: Boolean.</li> </ul> </li> <li> <p>unit: Dictionary with ID or name as key, or string with name, or string with ID.</p> </li> </ul> required <p>Returns:</p> Type Description <code>List[FieldData]</code> <p>List of FieldData objects representing the added fields.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def add_many_fields(self, data_list: List[Dict]) -&gt; List[\"FieldData\"]:\n    \"\"\"\n    Method to add many fields to the current item\n\n    Parameters\n    ----------\n    data_list: List[Dict]\n        List of dictionaries containing the information about the fields to be added. Each dictionary should have the following keys:\n\n        - field_name: Name of the field to be added. Either field_name and field_type or field_id must be specified.\n        - field_type:\n            Type of the field. Must be one of the following:\n\n            - Numeric fields: numeric, numeric-field, numeric_field\n            - Date fields: date, date_field, date-field, datefield\n            - Text fields: singleline, singlelinefield, text, text-field, text_field, textfield\n            - List fields: combobox, comboboxfield, list, list-field, list_field, listfield\n            - Notebook fields: multiline, notebook, notebookfield, notebook-field, notebook_field\n            - Checkbox fields: checkbox, checkbox-field, checkbox_field, checkboxfield\n            - Calculation fields: calculation, calculation-field, calculation_field, calculationfield\n\n        - field_id: ID of the field to be added.\n        - value: Value of the field. The required format depends on the field_type:\n\n            - Numeric: float or int, or a string convertible to a float.\n            - Date: datetime, date object, Unix timestamp, or string in ISO format.\n            - SingleLine: string.\n            - ComboBoxEntry: Dictionary with ID or name as key, or string with name, or string with ID.\n            - MultiLine: Dictionary with content as key, or string.\n            - CheckBox: Boolean.\n\n        - unit: Dictionary with ID or name as key, or string with name, or string with ID.\n\n    Returns\n    -------\n    List[\"FieldData\"]\n        List of FieldData objects representing the added fields.\n\n    \"\"\"\n\n\n    from .fielddata import FieldData\n    if not self._fetched:\n        self._get()\n\n    fielddata_list = FieldData.create_many(data_list)\n\n    new_field_data_list = list(self.fielddata)\n    new_field_data_list.extend(fielddata_list)\n    self.fielddata = new_field_data_list\n\n    data = {\"id\": self.id, \"fielddata\": [{\"id\": f.id} for f in self.fielddata]}\n    self._post(data)\n    return fielddata_list\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.create","title":"<code>create(name, group_name=None, group_id=None, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to create a new sample.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the sample to be created.</p> required <code>group_name</code> <code>str</code> <p>The name of the group where the new item will belong to. Group name can only be considered for groups that are not subgroups. Either group_name or group_id must be specified.</p> <code>None</code> <code>group_id</code> <code>int</code> <p>The ID of the group where the new item will belong to. Either group_name or group_id must be specified.</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Optionally to get samples from another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the sample class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither group_name nor group_id is specified.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, group_name: str = None, group_id: str = None, project_id: str = None) -&gt; Self:\n    \"\"\"\n    Method to create a new sample.\n\n    Parameters\n    ----------\n    name : str\n        The name of the sample to be created.\n\n    group_name : str, optional\n        The name of the group where the new item will belong to. Group name can only be considered for groups that are not subgroups.\n        Either group_name or group_id must be specified.\n\n    group_id : int, optional\n        The ID of the group where the new item will belong to.\n        Either group_name or group_id must be specified.\n    project_id : str, optional\n        Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        An instance of the sample class.\n\n    Raises\n    ------\n    AssertionError\n        If neither group_name nor group_id is specified.\n\n    \"\"\"\n\n    return Sample._create(name, group_name, group_id, project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.create_many","title":"<code>create_many(data_list, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to create many samples.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>A list of dictionaries representing the data for creating multiple samples. Each dictionary should have the following keys: - 'name': The name of the sample to be created. - 'group_name': The name of the group where the new item will belong to. The 'group_name' can only be considered for groups                 that are not subgroups. Either 'group_name' or 'group_id' must be specified. - 'group_id': The id of the group where the new item will belong to. Either 'group_name' or 'group_id' must be specified.</p> required <code>project_id</code> <code>str</code> <p>Optionally to get samples from another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Sample]</code> <p>A list of instances of the 'Sample' class, representing the created samples.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither group_name nor group_id is specified.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = None) -&gt; Self:\n    \"\"\"\n    Method to create many samples.\n\n    Parameters\n    ----------\n    data_list : List[Dict]\n        A list of dictionaries representing the data for creating multiple samples. Each dictionary should have the following keys:\n        - 'name': The name of the sample to be created.\n        - 'group_name': The name of the group where the new item will belong to. The 'group_name' can only be considered for groups\n                        that are not subgroups. Either 'group_name' or 'group_id' must be specified.\n        - 'group_id': The id of the group where the new item will belong to. Either 'group_name' or 'group_id' must be specified.\n\n    project_id : str, optional\n        Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Sample]\n        A list of instances of the 'Sample' class, representing the created samples.\n\n    Raises\n    ------\n    AssertionError\n        If neither group_name nor group_id is specified.\n\n    \"\"\"\n\n    return Sample._create_many(data_list, project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.get","title":"<code>get(id='', name='', shortid='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get one sample by its id, short_id, or name. If called on an instance of the class, the id of the instance is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id or short_id of the requested sample.</p> <code>''</code> <code>name</code> <code>str</code> <p>The name of the requested sample.</p> <code>''</code> <code>shortid</code> <code>str</code> <p>The shortid of the requested sample.</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to get the sample from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the sample class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If called as a class method and no id, shortid, or name is specified.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>@classmethod\ndef get(cls, id: str = \"\", name: str = \"\", shortid: str = \"\", project_id: str = \"\") -&gt; Self:\n    \"\"\"\n    Method to get one sample by its id, short_id, or name.\n    If called on an instance of the class, the id of the instance is used\n\n    Parameters\n    ----------\n    id : str\n        The id or short_id of the requested sample.\n    name : str\n        The name of the requested sample.\n    shortid : str\n        The shortid of the requested sample.\n    project_id : str, optional\n        Optionally to get the sample from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    Self\n        An instance of the sample class.\n\n    Raises\n    ------\n    AssertionError\n        If called as a class method and no id, shortid, or name is specified.\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id or name or shortid, \"Either id, shortid, or name must be specified\"\n\n    return cls._get(id, shortid, name, project_id=project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.get_all","title":"<code>get_all(project_id='')</code>  <code>classmethod</code>","text":"<p>Method to get all samples belonging to one project</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>Optionally to get samples from another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the <code>Sample</code> class representing the fetched samples.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>@classmethod\ndef get_all(cls, project_id: str = \"\") -&gt; List[Self]:\n    \"\"\"\n    Method to get all samples belonging to one project\n\n    Parameters\n    ----------\n    project_id : str, optional\n        Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the `Sample` class representing the fetched samples.\n    \"\"\"\n\n    return cls._get_all(project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.get_many","title":"<code>get_many(ids=(), shortids=(), names=(), project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to get many samples by its ids, short_ids, or names.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of sample ids to filter samples by.</p> <code>()</code> <code>shortids</code> <code>List[str]</code> <p>List of short ids to filter samples by.</p> <code>()</code> <code>names</code> <code>List[str]</code> <p>List of names to filter samples by.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>Optionally to get samples from another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the sample class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If neither ids, shortids, nor names are specified.</p> Source code in <code>furthrmind/collection/sample.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), shortids: List[str] = (), names: List[str] = (),\n             project_id: str = None) -&gt; List[Self]:\n    \"\"\"\n    Method to get many samples by its ids, short_ids, or names.\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of sample ids to filter samples by.\n    shortids : List[str]\n        List of short ids to filter samples by.\n    names : List[str]\n        List of names to filter samples by.\n    project_id : str, optional\n        Optionally to get samples from another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the sample class.\n\n    Raises\n    ------\n    AssertionError\n        If neither ids, shortids, nor names are specified.\n\n    \"\"\"\n\n    assert ids or names or shortids, \"Either ids, shortids, or names must be specified\"\n    return cls._get_many(ids, shortids, names, project_id=project_id)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.remove_field","title":"<code>remove_field(field_name='', field_id='')</code>","text":"<p>Removes a field from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field that should be removed. Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be removed.Either the <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>ID of the item after the field is removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_name</code> or <code>field_id</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_field(self, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Removes a field from the current item.\n\n    Parameters\n    ----------\n    field_name : str, optional\n        Name of the field that should be removed. Either the `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be removed.Either the `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    str\n        ID of the item after the field is removed.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_name` or `field_id`.\n    \"\"\"\n\n\n    if not self._fetched:\n        self._get()\n\n    new_fielddata_list = []\n    fielddata_to_be_removed = None\n    for fielddata in self.fielddata:\n        found = False\n        if field_id:\n            found = True\n            if fielddata.field_id == field_id:\n                fielddata_to_be_removed = fielddata\n        elif field_name:\n            found = True\n            if fielddata.field_name == field_name:\n                fielddata_to_be_removed = fielddata\n        if not found:\n            new_fielddata_list.append(fielddata)\n\n\n    if not fielddata_to_be_removed:\n        raise ValueError(\"No field found with the given fieldid or fieldname\")\n\n    self.fielddata = new_fielddata_list\n    fielddata_list = [{\"id\": fd.id} for fd in new_fielddata_list]\n    post_data = {\"id\": self.id, \"fielddata\": fielddata_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.remove_file","title":"<code>remove_file(file_id='', file_name='')</code>","text":"<p>Method to remove a file from the current item</p> <p>Parameters:</p> Name Type Description Default <code>file_id</code> <code>str</code> <p>ID of the file that should be removed. Either <code>file_id</code> or <code>file_name</code> must be specified.</p> <code>''</code> <code>file_name</code> <code>str</code> <p>Name of the file to be removed.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>file_object</code> <code>dict</code> <p>Object representing the removed file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no file is found with the given <code>file_id</code> or <code>file_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_file(self, file_id: str = \"\", file_name: str = \"\"):\n    \"\"\"\n    Method to remove a file from the current item\n\n    Parameters\n    ----------\n    file_id: str, optional\n        ID of the file that should be removed. Either `file_id` or `file_name` must be specified.\n    file_name: str, optional\n        Name of the file to be removed.\n\n    Returns\n    -------\n    file_object: dict\n        Object representing the removed file.\n\n    Raises\n    ------\n    ValueError\n        If no file is found with the given `file_id` or `file_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    new_file_list = []\n    file_to_be_removed = None\n    for file in self.files:\n        found = False\n        if file_id:\n            found = True\n            if file.id == file_id:\n                file_to_be_removed = file\n        elif file_name:\n            found = True\n            if file.name == file_name:\n                file_to_be_removed = file\n        if not found:\n            new_file_list.append(file)\n\n    if not file_to_be_removed:\n        raise ValueError(\"No file found with the given file_id or file_name\")\n\n    self.files = new_file_list\n    file_list = [{\"id\": f.id} for f in new_file_list]\n    post_data = {\"id\": self.id, \"files\": file_list}\n    id = self._post(post_data)\n    return id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.remove_linked_experiment","title":"<code>remove_linked_experiment(experiment_id='', experiment_name='')</code>","text":"<p>Method to remove a linked experiment from the current item.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_id</code> <code>str</code> <p>The ID of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <code>experiment_name</code> <code>str</code> <p>The name of the experiment you want to unlink. Either <code>experiment_id</code> or <code>experiment_name</code> must be given.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no experiment is found with the given name.</p> <code>AssertionError</code> <p>If neither <code>experiment_id</code> nor <code>experiment_name</code> is specified.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_experiment(self, experiment_id: str = \"\", experiment_name: str = \"\"):\n    \"\"\"\n    Method to remove a linked experiment from the current item.\n\n    Parameters\n    ----------\n    experiment_id : str, optional\n        The ID of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n    experiment_name : str, optional\n        The name of the experiment you want to unlink. Either `experiment_id` or `experiment_name` must be given.\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n\n    Raises\n    ------\n    ValueError\n        If no experiment is found with the given name.\n    AssertionError\n        If neither `experiment_id` nor `experiment_name` is specified.\n\n    \"\"\"\n\n    from furthrmind.collection import Experiment\n    assert experiment_id or experiment_name, \"Either experiment_id or experiment_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if experiment_name:\n        exp = Experiment.get(name = experiment_name)\n        if not exp:\n            raise ValueError(\"No exp found with the given name\")\n        experiment_id = exp.id\n\n    experiment_id_list = []\n    new_linked_items = []\n    for item in self.linked_experiments:\n        if item.id == experiment_id:\n            continue\n        new_linked_items.append(item)\n        experiment_id_list.append(item.id)\n\n    linked_experiment = [{\"id\": exp_id} for exp_id in experiment_id_list]\n    data = {\n        \"id\": self.id,\n            \"experiments\": linked_experiment\n    }\n\n    self._post(data=data)\n    self.linked_experiments = new_linked_items\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.remove_linked_researchitem","title":"<code>remove_linked_researchitem(researchitem_id)</code>","text":"<p>Method to remove a linked researchitem from the current item</p> <p>Parameters:</p> Name Type Description Default <code>researchitem_id</code> <code>str</code> <p>The ID of the research item you want to unlink</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the item after removing the linkage.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_researchitem(self, researchitem_id: str):\n    \"\"\"\n    Method to remove a linked researchitem from the current item\n\n    Parameters\n    ----------\n    researchitem_id : str\n        The ID of the research item you want to unlink\n\n    Returns\n    -------\n    str\n        The ID of the item after removing the linkage.\n    \"\"\"\n\n    assert researchitem_id, \"Either experiment_id must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    researchitem_id_list = []\n    new_linked_items = {}\n    for cat in self.linked_researchitems:\n        for item in self.linked_researchitems[cat]:\n            if item.id == researchitem_id:\n                continue\n            if cat not in new_linked_items:\n                new_linked_items[cat] = []\n            new_linked_items[cat].append(item)\n            researchitem_id_list.append(item.id)\n\n    if researchitem_id in researchitem_id_list:\n        researchitem_id_list.remove(researchitem_id)\n\n    linked_researchitems = [{\"id\": ri_id} for ri_id in researchitem_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"researchitems\": linked_researchitems\n    }\n\n    self._post(data=data)\n    self.linked_researchitems = new_linked_items\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.remove_linked_sample","title":"<code>remove_linked_sample(sample_id='', sample_name='')</code>","text":"<p>Method is to remove a linked sample from the current item</p> <p>Parameters:</p> Name Type Description Default <code>sample_id</code> <code>str</code> <p>The id of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <code>sample_name</code> <code>str</code> <p>The name of the sample you want to unlink. Either <code>sample_id</code> or <code>sample_name</code> must be provided.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sample is found with the given name.</p> Notes <p>This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def remove_linked_sample(self, sample_id: str = \"\", sample_name: str = \"\"):\n    \"\"\"\n    Method is to remove a linked sample from the current item\n\n    Parameters\n    ----------\n    sample_id : str, optional\n        The id of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n    sample_name : str, optional\n        The name of the sample you want to unlink. Either `sample_id` or `sample_name` must be provided.\n\n    Returns\n    -------\n    str\n        The id of the item.\n\n    Raises\n    ------\n    ValueError\n        If no sample is found with the given name.\n\n    Notes\n    -----\n    This method is used to remove a linked sample from the current item. It updates the list of linked samples for the item and saves the changes.\n\n    \"\"\"\n\n    from furthrmind.collection import Sample\n    assert sample_id or sample_name, \"Either sample_id or sample_name must be specified\"\n\n    if not self._fetched:\n        self._get()\n\n    if sample_name:\n        s = Sample.get(name=sample_name)\n        if not s:\n            raise ValueError(\"No sample found with the given name\")\n        sample_id = s.id\n\n    sample_id_list = []\n    new_linked_items = []\n    for item in self.linked_samples:\n        if item.id == sample_id:\n            continue\n        new_linked_items.append(item)\n        sample_id_list.append(item.id)\n\n    linked_samples = [{\"id\": s_id} for s_id in sample_id_list]\n\n    data = {\n        \"id\": self.id,\n        \"samples\": linked_samples\n    }\n    self._post(data=data)\n    self.linked_samples = new_linked_items\n    return self.id\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.set_calculation_result","title":"<code>set_calculation_result(value, field_name='', field_id='', fielddata_id='')</code>","text":"<p>Method to update a calculation result</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict</code> <p>Dictionary containing the calculation result to be set for the field.</p> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <code>fielddata_id</code> <code>str</code> <p>ID of the fielddata that should be updated. Either <code>field_name</code>, <code>field_id</code>, or <code>fielddata_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the fielddata that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def set_calculation_result(self, value: dict, field_name: str = \"\", field_id: str = \"\", fielddata_id: str = \"\"):\n    \"\"\"\n    Method to update a calculation result\n\n    Parameters\n    ----------\n    value : dict\n        Dictionary containing the calculation result to be set for the field.\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n    fielddata_id : str, optional\n        ID of the fielddata that should be updated. Either `field_name`, `field_id`, or `fielddata_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the fielddata that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if fielddata_id:\n            if item.id == fielddata_id:\n                fielddata = item\n        if field_id:\n            if item.fieldid == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.set_calculation_result(value)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.update_field_unit","title":"<code>update_field_unit(unit, field_name='', field_id='')</code>","text":"<p>Method to update the unit of a field.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Union[Dict, str]</code> <p>Dictionary with id or name, or string representing the name, or string representing the id.</p> required <code>field_name</code> <code>str</code> <p>The name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>The ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>id</code> <p>The ID of the updated field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_unit(self, unit: Union[Dict, str], field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Method to update the unit of a field.\n\n    Parameters\n    ----------\n    unit : Union[Dict, str]\n        Dictionary with id or name, or string representing the name, or string representing the id.\n    field_name : str, optional\n        The name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        The ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    id\n        The ID of the updated field.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata is not None:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_unit(unit)\n</code></pre>"},{"location":"sample/#furthrmind.collection.sample.Sample.update_field_value","title":"<code>update_field_value(value, field_name='', field_id='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>various data types</code> <p>The value to be updated in the field.</p> <ul> <li>Numeric fields: float or int, or a string convertible to a float</li> <li>Date fields: datetime, date object, unix timestamp, or string with iso format</li> <li>Text fields: string</li> <li>List fields: dictionary with id or name as key, or string with name, or string with id</li> <li>Notebook fields: dictionary with content as key, or string</li> <li>Checkbox fields: boolean</li> </ul> required <code>field_name</code> <code>str</code> <p>Name of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <code>field_id</code> <code>str</code> <p>ID of the field that should be updated. Either <code>field_name</code> or <code>field_id</code> must be specified.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the field that was updated.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no field is found with the given <code>field_id</code> or <code>field_name</code>.</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def update_field_value(self, value, field_name: str = \"\", field_id: str = \"\"):\n    \"\"\"\n    Parameters\n    ----------\n    value : various data types\n        The value to be updated in the field.\n\n        - Numeric fields: float or int, or a string convertible to a float\n        - Date fields: datetime, date object, unix timestamp, or string with iso format\n        - Text fields: string\n        - List fields: dictionary with id or name as key, or string with name, or string with id\n        - Notebook fields: dictionary with content as key, or string\n        - Checkbox fields: boolean\n    field_name : str, optional\n        Name of the field that should be updated. Either `field_name` or `field_id` must be specified.\n    field_id : str, optional\n        ID of the field that should be updated. Either `field_name` or `field_id` must be specified.\n\n    Returns\n    -------\n    int\n        The ID of the field that was updated.\n\n    Raises\n    ------\n    ValueError\n        If no field is found with the given `field_id` or `field_name`.\n    \"\"\"\n\n    if not self._fetched:\n        self._get()\n\n    fielddata = None\n    for item in self.fielddata:\n        if fielddata:\n            break\n        if field_id:\n            if item.field_id == field_id:\n                fielddata = item\n        elif field_name:\n            if item.field_name.lower() == field_name.lower():\n                fielddata = item\n\n    if not fielddata:\n        raise ValueError(\"No field found with the given field_id or field_name\")\n\n    return fielddata.update_value(value)\n</code></pre>"},{"location":"unit/","title":"Unit","text":""},{"location":"unit/#furthrmind.collection.unit.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>BaseClass</code></p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>id of the unit</p> <code>name</code> <code>str</code> <p>name of the unit</p> <code>longname</code> <code>str</code> <p>Long name of the unit. In case of \"cm\" this would be centimeter</p> <code>definition</code> <code>str</code> <p>In case of self defined units, this attributes gives the definition of the unit in si units</p> Source code in <code>furthrmind/collection/unit.py</code> <pre><code>class Unit(BaseClass):\n    \"\"\"\n    Attributes\n    ----------\n    id : str\n        id of the unit\n    name : str\n        name of the unit\n    longname : str\n        Long name of the unit. In case of \"cm\" this would be centimeter\n    definition : str\n        In case of self defined units, this attributes gives the definition of the unit in si units\n    \"\"\"\n\n    id = \"\"\n    name = \"\"\n    longname = \"\"\n    definition = \"\"\n\n    _attr_definition = {\n    }\n\n    def __init__(self, id=None, data=None):\n        super().__init__(id, data)\n\n    def _get_url_instance(self, project_id=None):\n        project_url = Unit.fm.get_project_url(project_id)\n        url = f\"{project_url}/units/{self.id}\"\n        return url\n\n    @classmethod\n    def _get_url_class(cls, id, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/units/{id}\"\n        return url\n\n    @classmethod\n    def _get_all_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/units\"\n        return url\n\n    @classmethod\n    def _post_url(cls, project_id=None):\n        project_url = cls.fm.get_project_url(project_id)\n        url = f\"{project_url}/units\"\n        return url\n\n    @classmethod\n    def get(cls, id: str = None) -&gt; Self:\n        \"\"\"\n        Method to get one unit.\n        If called on an instance of the class, the id of the instance is used\n\n        Parameters\n        ----------\n        id : str, optional\n            The id of the unit to be retrieved. If not specified, the id of the instance is used.\n\n        Returns\n        -------\n        Self\n            An instance of the unit class.\n\n        \"\"\"\n\n        if isclass(cls):\n            assert id, \"id must be specified\"\n            return cls._get_class_method(id)\n        else:\n            self = cls\n            data = self._get_instance_method()\n            return data\n\n    @classmethod\n    def get_many(cls, ids: List[str] = (), project_id=None) -&gt; List[Self]:\n        \"\"\"\n        This method is used to retrieve many units belonging to one project.\n\n        Parameters\n        ----------\n        ids : List[str]\n            List of ids.\n        project_id : str, optional\n            The project id. Defaults to None.\n\n        Returns\n        -------\n        List[Self]\n            List of instances of the experiment class.\n\n        Raises\n        ------\n        TypeError\n            If ids is not a list.\n        \"\"\"\n\n        return super()._get_many(ids, project_id=project_id)\n\n    @classmethod\n    def _get_all(cls, project_id=None) -&gt; List[Self]:\n        \"\"\"\n        Method to get all units belonging to one project\n\n        Parameters\n        ----------\n        project_id : str\n            Optionally specify the project ID to get units from. Defaults to None.\n\n        Returns\n        -------\n        List[Self]\n            A list containing instances of the unit class.\n        \"\"\"\n\n        return super()._get_all(project_id)\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create(cls, name: str, definition: str = None, project_id: str = None) -&gt; Self:\n        \"\"\"\n        Method to create a new unit.\n\n        Parameters\n        ----------\n        name : str\n            Name of the new unit\n        definition : str, optional\n            Unit definition in SI units to convert the new unit to an SI value. E.g. for unit cm\u00b2, the definition would be 'cm*cm'.\n            For valid units, please check the web app and open the unit editor. You will find a list of valid units. A definition may also contain scalar values.\n        project_id : any, optional\n            Project ID to create an item in another project\n\n        Returns\n        -------\n        Self\n            Instance of the unit class\n\n        Raises\n        ------\n        AssertationError\n            If name is not provided\n        \"\"\"\n\n        assert name, \"Name must be provided\"\n\n        data = {\"name\": name, \"definition\": definition}\n        id = cls._post(data, project_id)\n        data[\"id\"] = id\n        return data\n\n    @classmethod\n    @BaseClass._create_instances_decorator(_fetched=False)\n    def create_many(cls, data_list: List[Dict], project_id: str = None) -&gt; Self:\n        \"\"\"\n        Parameters\n        ----------\n        data_list : List[Dict]\n            A list of dictionaries containing the information for creating new units.\n            Each dictionary should have the following keys:\n            - name : str\n                Name of the new unit.\n            - definition : str\n                Unit definition in SI units to convert the new unit to an SI Value.\n                For example, for unit cm\u00b2, the definition would be 'cm * cm'.\n                For valid units, please check the web app unit editor.\n                A definition can also contain scalar values.\n\n        project_id : str, optional\n            Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n        Returns\n        -------\n        List[Self]\n            A list with instances of the unit class\n\n        Raises\n        ------\n        AssertationError\n            If the name parameter is missing for any unit in the data_list.\n        \"\"\"\n\n        new_data_list = []\n        for data in data_list:\n            name = data.get(\"name\")\n            definition = data.get(\"definition\")\n\n            assert name, \"Name is required\"\n\n            data = {\"name\": name, \"definition\": definition}\n            new_data_list.append(data)\n\n        id_list = cls._post(new_data_list, project_id, force_list=True)\n        for data, id in zip(new_data_list, id_list):\n            data[\"id\"] = id\n\n        return new_data_list\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.create","title":"<code>create(name, definition=None, project_id=None)</code>  <code>classmethod</code>","text":"<p>Method to create a new unit.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the new unit</p> required <code>definition</code> <code>str</code> <p>Unit definition in SI units to convert the new unit to an SI value. E.g. for unit cm\u00b2, the definition would be 'cm*cm'. For valid units, please check the web app and open the unit editor. You will find a list of valid units. A definition may also contain scalar values.</p> <code>None</code> <code>project_id</code> <code>any</code> <p>Project ID to create an item in another project</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Instance of the unit class</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If name is not provided</p> Source code in <code>furthrmind/collection/unit.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create(cls, name: str, definition: str = None, project_id: str = None) -&gt; Self:\n    \"\"\"\n    Method to create a new unit.\n\n    Parameters\n    ----------\n    name : str\n        Name of the new unit\n    definition : str, optional\n        Unit definition in SI units to convert the new unit to an SI value. E.g. for unit cm\u00b2, the definition would be 'cm*cm'.\n        For valid units, please check the web app and open the unit editor. You will find a list of valid units. A definition may also contain scalar values.\n    project_id : any, optional\n        Project ID to create an item in another project\n\n    Returns\n    -------\n    Self\n        Instance of the unit class\n\n    Raises\n    ------\n    AssertationError\n        If name is not provided\n    \"\"\"\n\n    assert name, \"Name must be provided\"\n\n    data = {\"name\": name, \"definition\": definition}\n    id = cls._post(data, project_id)\n    data[\"id\"] = id\n    return data\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.create_many","title":"<code>create_many(data_list, project_id=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>List[Dict]</code> <p>A list of dictionaries containing the information for creating new units. Each dictionary should have the following keys: - name : str     Name of the new unit. - definition : str     Unit definition in SI units to convert the new unit to an SI Value.     For example, for unit cm\u00b2, the definition would be 'cm * cm'.     For valid units, please check the web app unit editor.     A definition can also contain scalar values.</p> required <code>project_id</code> <code>str</code> <p>Optionally to create an item in another project as the furthrmind sdk was initiated with</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>A list with instances of the unit class</p> <p>Raises:</p> Type Description <code>AssertationError</code> <p>If the name parameter is missing for any unit in the data_list.</p> Source code in <code>furthrmind/collection/unit.py</code> <pre><code>@classmethod\n@BaseClass._create_instances_decorator(_fetched=False)\ndef create_many(cls, data_list: List[Dict], project_id: str = None) -&gt; Self:\n    \"\"\"\n    Parameters\n    ----------\n    data_list : List[Dict]\n        A list of dictionaries containing the information for creating new units.\n        Each dictionary should have the following keys:\n        - name : str\n            Name of the new unit.\n        - definition : str\n            Unit definition in SI units to convert the new unit to an SI Value.\n            For example, for unit cm\u00b2, the definition would be 'cm * cm'.\n            For valid units, please check the web app unit editor.\n            A definition can also contain scalar values.\n\n    project_id : str, optional\n        Optionally to create an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    List[Self]\n        A list with instances of the unit class\n\n    Raises\n    ------\n    AssertationError\n        If the name parameter is missing for any unit in the data_list.\n    \"\"\"\n\n    new_data_list = []\n    for data in data_list:\n        name = data.get(\"name\")\n        definition = data.get(\"definition\")\n\n        assert name, \"Name is required\"\n\n        data = {\"name\": name, \"definition\": definition}\n        new_data_list.append(data)\n\n    id_list = cls._post(new_data_list, project_id, force_list=True)\n    for data, id in zip(new_data_list, id_list):\n        data[\"id\"] = id\n\n    return new_data_list\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.delete","title":"<code>delete(id='', project_id='')</code>  <code>classmethod</code>","text":"<p>Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance of a class</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the resource to delete</p> <code>''</code> <code>project_id</code> <code>str</code> <p>Optionally to delete an item in another project as the furthrmind sdk was initiated with</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The id of the item</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>@classmethod\ndef delete(cls, id: str = \"\", project_id: str = \"\") -&gt; str:\n    \"\"\"\n    Method to delete an item. Can be called as a classmethod with providing the id to be deleted or on the instance\n    of a class\n\n    Parameters\n    ----------\n    id : str\n        The id of the resource to delete\n    project_id : str, optional\n        Optionally to delete an item in another project as the furthrmind sdk was initiated with\n\n    Returns\n    -------\n    str\n        The id of the item\n    \"\"\"\n\n    if isclass(cls):\n        return cls._delete_class_method(id, project_id)\n    else:\n        self = cls\n        return self._delete_instance_method(project_id)\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.get","title":"<code>get(id=None)</code>  <code>classmethod</code>","text":"<p>Method to get one unit. If called on an instance of the class, the id of the instance is used</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the unit to be retrieved. If not specified, the id of the instance is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the unit class.</p> Source code in <code>furthrmind/collection/unit.py</code> <pre><code>@classmethod\ndef get(cls, id: str = None) -&gt; Self:\n    \"\"\"\n    Method to get one unit.\n    If called on an instance of the class, the id of the instance is used\n\n    Parameters\n    ----------\n    id : str, optional\n        The id of the unit to be retrieved. If not specified, the id of the instance is used.\n\n    Returns\n    -------\n    Self\n        An instance of the unit class.\n\n    \"\"\"\n\n    if isclass(cls):\n        assert id, \"id must be specified\"\n        return cls._get_class_method(id)\n    else:\n        self = cls\n        data = self._get_instance_method()\n        return data\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.get_many","title":"<code>get_many(ids=(), project_id=None)</code>  <code>classmethod</code>","text":"<p>This method is used to retrieve many units belonging to one project.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>List[str]</code> <p>List of ids.</p> <code>()</code> <code>project_id</code> <code>str</code> <p>The project id. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Self]</code> <p>List of instances of the experiment class.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If ids is not a list.</p> Source code in <code>furthrmind/collection/unit.py</code> <pre><code>@classmethod\ndef get_many(cls, ids: List[str] = (), project_id=None) -&gt; List[Self]:\n    \"\"\"\n    This method is used to retrieve many units belonging to one project.\n\n    Parameters\n    ----------\n    ids : List[str]\n        List of ids.\n    project_id : str, optional\n        The project id. Defaults to None.\n\n    Returns\n    -------\n    List[Self]\n        List of instances of the experiment class.\n\n    Raises\n    ------\n    TypeError\n        If ids is not a list.\n    \"\"\"\n\n    return super()._get_many(ids, project_id=project_id)\n</code></pre>"},{"location":"unit/#furthrmind.collection.unit.Unit.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object's attributes to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).</p> Source code in <code>furthrmind/collection/baseclass.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Converts the object's attributes to a dictionary representation.\n\n    Returns\n    -------\n    dict\n        Dictionary containing the object's attributes (excluding private attributes, callable attributes, and attributes of type Furthrmind).\n    \"\"\"\n\n    from furthrmind import Furthrmind\n    data = {}\n    for attr in dir(self):\n        if attr.startswith('_'):\n            continue\n        value = getattr(self, attr)\n        if callable(value):\n            continue\n        if isinstance(value, Furthrmind):\n            continue\n        data[attr] = self._convert(value)\n    return data\n</code></pre>"}]}